The system is: Linux - 3.2.16-030216-generic - i686
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /toolchain/bin/i486-TSOL-linux-gnu-gcc 
Build flags: -O2
Id flags: 

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is GNU, found in "/source/cmake-2.8.10.2/CMakeFiles/2.8.10.2/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /toolchain/bin/i486-TSOL-linux-gnu-g++ 
Build flags: -O2
Id flags: 

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is GNU, found in "/source/cmake-2.8.10.2/CMakeFiles/2.8.10.2/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3914251992/fast"
make -f CMakeFiles/cmTryCompileExec3914251992.dir/build.make CMakeFiles/cmTryCompileExec3914251992.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3914251992.dir/testCCompiler.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3914251992.dir/testCCompiler.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTryCompileExec3914251992
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3914251992.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec3914251992.dir/testCCompiler.c.o  -o cmTryCompileExec3914251992 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Detecting C compiler ABI info compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3134228373/fast"
make -f CMakeFiles/cmTryCompileExec3134228373.dir/build.make CMakeFiles/cmTryCompileExec3134228373.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o   -c /source/cmake-2.8.10.2/Modules/CMakeCCompilerABI.c
Linking C executable cmTryCompileExec3134228373
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3134228373.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2     -v CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3134228373 -rdynamic  
Using built-in specs.
COLLECT_GCC=/toolchain/bin/i486-TSOL-linux-gnu-gcc
COLLECT_LTO_WRAPPER=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/lto-wrapper
Target: i486-TSOL-linux-gnu
Configured with: /TSOL/crosstool-ng-1.15.2/bin/.build/src/gcc-4.6.3/configure --build=i686-build_pc-linux-gnu --host=i686-build_pc-linux-gnu --target=i486-TSOL-linux-gnu --prefix=/toolchain --with-sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-languages=c,c++ --with-arch=i486 --with-pkgversion='crosstool-NG 1.15.2' --enable-__cxa_atexit --disable-libmudflap --disable-libgomp --disable-libssp --with-gmp=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpfr=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpc=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-ppl=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-cloog=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-libelf=no --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm -L/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools/lib -lpwl' --enable-threads=posix --enable-target-optspace --disable-multilib --with-local-prefix=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-c99 --enable-long-long
Thread model: posix
gcc version 4.6.3 (crosstool-NG 1.15.2) 
COMPILER_PATH=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/bin/
LIBRARY_PATH=/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/
COLLECT_GCC_OPTIONS='-O2' '-v' '-o' 'cmTryCompileExec3134228373' '-rdynamic' '-mtune=i486' '-march=i486'
 /toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/collect2 --sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --eh-frame-hdr -m elf_i386 -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec3134228373 /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crt1.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crti.o /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtbegin.o -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3 -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtend.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crtn.o
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec3134228373/fast"]
  ignore line: [make -f CMakeFiles/cmTryCompileExec3134228373.dir/build.make CMakeFiles/cmTryCompileExec3134228373.dir/build]
  ignore line: [make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp']
  ignore line: [/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building C object CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o]
  ignore line: [/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o   -c /source/cmake-2.8.10.2/Modules/CMakeCCompilerABI.c]
  ignore line: [Linking C executable cmTryCompileExec3134228373]
  ignore line: [/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3134228373.dir/link.txt --verbose=1]
  ignore line: [/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2     -v CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec3134228373 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/toolchain/bin/i486-TSOL-linux-gnu-gcc]
  ignore line: [COLLECT_LTO_WRAPPER=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/lto-wrapper]
  ignore line: [Target: i486-TSOL-linux-gnu]
  ignore line: [Configured with: /TSOL/crosstool-ng-1.15.2/bin/.build/src/gcc-4.6.3/configure --build=i686-build_pc-linux-gnu --host=i686-build_pc-linux-gnu --target=i486-TSOL-linux-gnu --prefix=/toolchain --with-sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-languages=c,c++ --with-arch=i486 --with-pkgversion='crosstool-NG 1.15.2' --enable-__cxa_atexit --disable-libmudflap --disable-libgomp --disable-libssp --with-gmp=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpfr=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpc=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-ppl=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-cloog=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-libelf=no --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm -L/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools/lib -lpwl' --enable-threads=posix --enable-target-optspace --disable-multilib --with-local-prefix=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-c99 --enable-long-long]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.6.3 (crosstool-NG 1.15.2) ]
  ignore line: [COMPILER_PATH=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/bin/]
  ignore line: [LIBRARY_PATH=/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-O2' '-v' '-o' 'cmTryCompileExec3134228373' '-rdynamic' '-mtune=i486' '-march=i486']
  link line: [ /toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/collect2 --sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --eh-frame-hdr -m elf_i386 -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec3134228373 /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crt1.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crti.o /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtbegin.o -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3 -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtend.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crtn.o]
    arg [/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/collect2] ==> ignore
    arg [--sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_i386] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib/ld-linux.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec3134228373] ==> ignore
    arg [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crt1.o] ==> ignore
    arg [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crti.o] ==> ignore
    arg [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtbegin.o] ==> ignore
    arg [-L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3] ==> dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3]
    arg [-L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib] ==> dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib]
    arg [-L/toolchain/i486-TSOL-linux-gnu/sysroot/lib] ==> dir [/toolchain/i486-TSOL-linux-gnu/sysroot/lib]
    arg [-L/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib] ==> dir [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib]
    arg [CMakeFiles/cmTryCompileExec3134228373.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtend.o] ==> ignore
    arg [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crtn.o] ==> ignore
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  collapse dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3] ==> [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3]
  collapse dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib] ==> [/toolchain/i486-TSOL-linux-gnu/lib]
  collapse dir [/toolchain/i486-TSOL-linux-gnu/sysroot/lib] ==> [/toolchain/i486-TSOL-linux-gnu/sysroot/lib]
  collapse dir [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib] ==> [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib]
  implicit libs: [c]
  implicit dirs: [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3;/toolchain/i486-TSOL-linux-gnu/lib;/toolchain/i486-TSOL-linux-gnu/sysroot/lib;/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib]


Determining if the CXX compiler works passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1741207440/fast"
make -f CMakeFiles/cmTryCompileExec1741207440.dir/build.make CMakeFiles/cmTryCompileExec1741207440.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1741207440.dir/testCXXCompiler.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -o CMakeFiles/cmTryCompileExec1741207440.dir/testCXXCompiler.cxx.o -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTryCompileExec1741207440
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1741207440.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1741207440.dir/testCXXCompiler.cxx.o  -o cmTryCompileExec1741207440 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2977371001/fast"
make -f CMakeFiles/cmTryCompileExec2977371001.dir/build.make CMakeFiles/cmTryCompileExec2977371001.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -o CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o -c /source/cmake-2.8.10.2/Modules/CMakeCXXCompilerABI.cpp
Linking CXX executable cmTryCompileExec2977371001
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2977371001.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2     -v CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2977371001 -rdynamic  
Using built-in specs.
COLLECT_GCC=/toolchain/bin/i486-TSOL-linux-gnu-g++
COLLECT_LTO_WRAPPER=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/lto-wrapper
Target: i486-TSOL-linux-gnu
Configured with: /TSOL/crosstool-ng-1.15.2/bin/.build/src/gcc-4.6.3/configure --build=i686-build_pc-linux-gnu --host=i686-build_pc-linux-gnu --target=i486-TSOL-linux-gnu --prefix=/toolchain --with-sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-languages=c,c++ --with-arch=i486 --with-pkgversion='crosstool-NG 1.15.2' --enable-__cxa_atexit --disable-libmudflap --disable-libgomp --disable-libssp --with-gmp=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpfr=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpc=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-ppl=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-cloog=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-libelf=no --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm -L/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools/lib -lpwl' --enable-threads=posix --enable-target-optspace --disable-multilib --with-local-prefix=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-c99 --enable-long-long
Thread model: posix
gcc version 4.6.3 (crosstool-NG 1.15.2) 
COMPILER_PATH=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/bin/
LIBRARY_PATH=/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/
COLLECT_GCC_OPTIONS='-O2' '-v' '-o' 'cmTryCompileExec2977371001' '-rdynamic' '-shared-libgcc' '-mtune=i486' '-march=i486'
 /toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/collect2 --sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --eh-frame-hdr -m elf_i386 -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec2977371001 /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crt1.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crti.o /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtbegin.o -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3 -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtend.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crtn.o
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec2977371001/fast"]
  ignore line: [make -f CMakeFiles/cmTryCompileExec2977371001.dir/build.make CMakeFiles/cmTryCompileExec2977371001.dir/build]
  ignore line: [make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp']
  ignore line: [/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building CXX object CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -o CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o -c /source/cmake-2.8.10.2/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Linking CXX executable cmTryCompileExec2977371001]
  ignore line: [/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2977371001.dir/link.txt --verbose=1]
  ignore line: [/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2     -v CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec2977371001 -rdynamic  ]
  ignore line: [Using built-in specs.]
  ignore line: [COLLECT_GCC=/toolchain/bin/i486-TSOL-linux-gnu-g++]
  ignore line: [COLLECT_LTO_WRAPPER=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/lto-wrapper]
  ignore line: [Target: i486-TSOL-linux-gnu]
  ignore line: [Configured with: /TSOL/crosstool-ng-1.15.2/bin/.build/src/gcc-4.6.3/configure --build=i686-build_pc-linux-gnu --host=i686-build_pc-linux-gnu --target=i486-TSOL-linux-gnu --prefix=/toolchain --with-sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-languages=c,c++ --with-arch=i486 --with-pkgversion='crosstool-NG 1.15.2' --enable-__cxa_atexit --disable-libmudflap --disable-libgomp --disable-libssp --with-gmp=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpfr=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-mpc=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-ppl=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-cloog=/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools --with-libelf=no --with-host-libstdcxx='-static-libgcc -Wl,-Bstatic,-lstdc++,-Bdynamic -lm -L/TSOL/crosstool-ng-1.15.2/bin/.build/i486-TSOL-linux-gnu/buildtools/lib -lpwl' --enable-threads=posix --enable-target-optspace --disable-multilib --with-local-prefix=/toolchain/i486-TSOL-linux-gnu/sysroot --enable-c99 --enable-long-long]
  ignore line: [Thread model: posix]
  ignore line: [gcc version 4.6.3 (crosstool-NG 1.15.2) ]
  ignore line: [COMPILER_PATH=/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/libexec/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/bin/]
  ignore line: [LIBRARY_PATH=/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/:/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/lib/:/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/]
  ignore line: [COLLECT_GCC_OPTIONS='-O2' '-v' '-o' 'cmTryCompileExec2977371001' '-rdynamic' '-shared-libgcc' '-mtune=i486' '-march=i486']
  link line: [ /toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/collect2 --sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot --eh-frame-hdr -m elf_i386 -export-dynamic -dynamic-linker /lib/ld-linux.so.2 -o cmTryCompileExec2977371001 /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crt1.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crti.o /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtbegin.o -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3 -L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/lib -L/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtend.o /toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crtn.o]
    arg [/toolchain/libexec/gcc/i486-TSOL-linux-gnu/4.6.3/collect2] ==> ignore
    arg [--sysroot=/toolchain/i486-TSOL-linux-gnu/sysroot] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_i386] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib/ld-linux.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec2977371001] ==> ignore
    arg [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crt1.o] ==> ignore
    arg [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crti.o] ==> ignore
    arg [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtbegin.o] ==> ignore
    arg [-L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3] ==> dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3]
    arg [-L/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib] ==> dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib]
    arg [-L/toolchain/i486-TSOL-linux-gnu/sysroot/lib] ==> dir [/toolchain/i486-TSOL-linux-gnu/sysroot/lib]
    arg [-L/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib] ==> dir [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib]
    arg [CMakeFiles/cmTryCompileExec2977371001.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/crtend.o] ==> ignore
    arg [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib/crtn.o] ==> ignore
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  collapse dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3] ==> [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3]
  collapse dir [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3/../../../../i486-TSOL-linux-gnu/lib] ==> [/toolchain/i486-TSOL-linux-gnu/lib]
  collapse dir [/toolchain/i486-TSOL-linux-gnu/sysroot/lib] ==> [/toolchain/i486-TSOL-linux-gnu/sysroot/lib]
  collapse dir [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib] ==> [/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib]
  implicit libs: [stdc++;m;c]
  implicit dirs: [/toolchain/lib/gcc/i486-TSOL-linux-gnu/4.6.3;/toolchain/i486-TSOL-linux-gnu/lib;/toolchain/i486-TSOL-linux-gnu/sysroot/lib;/toolchain/i486-TSOL-linux-gnu/sysroot/usr/lib]


Determining if the include file iostream exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2286019987/fast"
make -f CMakeFiles/cmTryCompileExec2286019987.dir/build.make CMakeFiles/cmTryCompileExec2286019987.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2286019987.dir/CheckIncludeFile.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -o CMakeFiles/cmTryCompileExec2286019987.dir/CheckIncludeFile.cxx.o -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec2286019987
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2286019987.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -static-libgcc CMakeFiles/cmTryCompileExec2286019987.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec2286019987 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has std namespace passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1138202883/fast"
make -f CMakeFiles/cmTryCompileExec1138202883.dir/build.make CMakeFiles/cmTryCompileExec1138202883.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1138202883.dir/TestForSTDNamespace.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -o CMakeFiles/cmTryCompileExec1138202883.dir/TestForSTDNamespace.cxx.o -c /source/cmake-2.8.10.2/Modules/TestForSTDNamespace.cxx
Linking CXX executable cmTryCompileExec1138202883
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1138202883.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -static-libgcc CMakeFiles/cmTryCompileExec1138202883.dir/TestForSTDNamespace.cxx.o  -o cmTryCompileExec1138202883 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler understands ansi for scopes passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3844660913/fast"
make -f CMakeFiles/cmTryCompileExec3844660913.dir/build.make CMakeFiles/cmTryCompileExec3844660913.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3844660913.dir/TestForAnsiForScope.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -o CMakeFiles/cmTryCompileExec3844660913.dir/TestForAnsiForScope.cxx.o -c /source/cmake-2.8.10.2/Modules/TestForAnsiForScope.cxx
Linking CXX executable cmTryCompileExec3844660913
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3844660913.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -static-libgcc CMakeFiles/cmTryCompileExec3844660913.dir/TestForAnsiForScope.cxx.o  -o cmTryCompileExec3844660913 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has sstream passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec741249235/fast"
make -f CMakeFiles/cmTryCompileExec741249235.dir/build.make CMakeFiles/cmTryCompileExec741249235.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec741249235.dir/TestForSSTREAM.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -o CMakeFiles/cmTryCompileExec741249235.dir/TestForSSTREAM.cxx.o -c /source/cmake-2.8.10.2/Modules/TestForSSTREAM.cxx
Linking CXX executable cmTryCompileExec741249235
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec741249235.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2       -static-libgcc CMakeFiles/cmTryCompileExec741249235.dir/TestForSSTREAM.cxx.o  -o cmTryCompileExec741249235 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the unsetenv exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3710962785/fast"
make -f CMakeFiles/cmTryCompileExec3710962785.dir/build.make CMakeFiles/cmTryCompileExec3710962785.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3710962785.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3710962785.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3710962785
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3710962785.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec3710962785.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3710962785 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdlib.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef unsetenv
  return ((int*)(&unsetenv))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Checking whether header cstdio is available compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec951714239/fast"
make -f CMakeFiles/cmTryCompileExec951714239.dir/build.make CMakeFiles/cmTryCompileExec951714239.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec951714239.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_CSTDIO -O2      -o CMakeFiles/cmTryCompileExec951714239.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec951714239
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec951714239.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec951714239.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec951714239 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for Large File Support compiled and ran with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2263366496/fast"
make -f CMakeFiles/cmTryCompileExec2263366496.dir/build.make CMakeFiles/cmTryCompileExec2263366496.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2263366496.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_CXX_HAS_CSTDIO=1 -DTEST_KWSYS_LFS_WORKS -O2      -o CMakeFiles/cmTryCompileExec2263366496.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2263366496
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2263366496.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2263366496.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2263366496 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether STL classes are in std namespace compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3772343734/fast"
make -f CMakeFiles/cmTryCompileExec3772343734.dir/build.make CMakeFiles/cmTryCompileExec3772343734.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3772343734.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_STL_HAVE_STD -O2      -o CMakeFiles/cmTryCompileExec3772343734.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3772343734
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3772343734.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3772343734.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3772343734 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI stream headers are available compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2296946416/fast"
make -f CMakeFiles/cmTryCompileExec2296946416.dir/build.make CMakeFiles/cmTryCompileExec2296946416.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2296946416.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_IOS_USE_ANSI -O2      -o CMakeFiles/cmTryCompileExec2296946416.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2296946416
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2296946416.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2296946416.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2296946416 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI streams are in std namespace compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec993167371/fast"
make -f CMakeFiles/cmTryCompileExec993167371.dir/build.make CMakeFiles/cmTryCompileExec993167371.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec993167371.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_IOS_HAVE_STD -O2      -o CMakeFiles/cmTryCompileExec993167371.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec993167371
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec993167371.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec993167371.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec993167371 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI string stream is available compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3488908090/fast"
make -f CMakeFiles/cmTryCompileExec3488908090.dir/build.make CMakeFiles/cmTryCompileExec3488908090.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3488908090.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_IOS_USE_SSTREAM -O2      -o CMakeFiles/cmTryCompileExec3488908090.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3488908090
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3488908090.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3488908090.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3488908090 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether header cstddef is available compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1498867036/fast"
make -f CMakeFiles/cmTryCompileExec1498867036.dir/build.make CMakeFiles/cmTryCompileExec1498867036.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1498867036.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_CSTDDEF -O2      -o CMakeFiles/cmTryCompileExec1498867036.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1498867036
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1498867036.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1498867036.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1498867036 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl string has operator!= for char* compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec874723735/fast"
make -f CMakeFiles/cmTryCompileExec874723735.dir/build.make CMakeFiles/cmTryCompileExec874723735.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec874723735.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_STRING_HAVE_NEQ_CHAR -O2      -o CMakeFiles/cmTryCompileExec874723735.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec874723735
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec874723735.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec874723735.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec874723735 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has iterator_traits compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1392939199/fast"
make -f CMakeFiles/cmTryCompileExec1392939199.dir/build.make CMakeFiles/cmTryCompileExec1392939199.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1392939199.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ITERATOR_TRAITS -O2      -o CMakeFiles/cmTryCompileExec1392939199.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1392939199
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1392939199.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1392939199.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1392939199 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has standard template allocator compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec415929826/fast"
make -f CMakeFiles/cmTryCompileExec415929826.dir/build.make CMakeFiles/cmTryCompileExec415929826.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec415929826.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_TEMPLATE -O2      -o CMakeFiles/cmTryCompileExec415929826.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec415929826
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec415929826.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec415929826.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec415929826 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for rebind member of stl allocator compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3425178746/fast"
make -f CMakeFiles/cmTryCompileExec3425178746.dir/build.make CMakeFiles/cmTryCompileExec3425178746.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3425178746.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_REBIND -O2      -o CMakeFiles/cmTryCompileExec3425178746.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3425178746
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3425178746.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3425178746.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3425178746 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl containers support allocator objects. compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec916822715/fast"
make -f CMakeFiles/cmTryCompileExec916822715.dir/build.make CMakeFiles/cmTryCompileExec916822715.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec916822715.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_STL_HAVE_STD=1 -DTEST_KWSYS_STL_HAS_ALLOCATOR_OBJECTS -O2      -o CMakeFiles/cmTryCompileExec916822715.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec916822715
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec916822715.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec916822715.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec916822715 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ios has binary openmode compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec96559402/fast"
make -f CMakeFiles/cmTryCompileExec96559402.dir/build.make CMakeFiles/cmTryCompileExec96559402.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec96559402.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAVE_BINARY -O2      -o CMakeFiles/cmTryCompileExec96559402.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec96559402
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec96559402.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec96559402.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec96559402 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for member template support compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec401772924/fast"
make -f CMakeFiles/cmTryCompileExec401772924.dir/build.make CMakeFiles/cmTryCompileExec401772924.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec401772924.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_MEMBER_TEMPLATES -O2      -o CMakeFiles/cmTryCompileExec401772924.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec401772924
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec401772924.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec401772924.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec401772924 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for standard template specialization syntax compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4212340700/fast"
make -f CMakeFiles/cmTryCompileExec4212340700.dir/build.make CMakeFiles/cmTryCompileExec4212340700.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4212340700.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_FULL_SPECIALIZATION -O2      -o CMakeFiles/cmTryCompileExec4212340700.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4212340700
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4212340700.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4212340700.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4212340700 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether argument dependent lookup is supported compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2894028749/fast"
make -f CMakeFiles/cmTryCompileExec2894028749.dir/build.make CMakeFiles/cmTryCompileExec2894028749.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2894028749.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_ARGUMENT_DEPENDENT_LOOKUP -O2      -o CMakeFiles/cmTryCompileExec2894028749.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2894028749
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2894028749.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2894028749.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2894028749 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether struct stat has st_mtim member compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1149010363/fast"
make -f CMakeFiles/cmTryCompileExec1149010363.dir/build.make CMakeFiles/cmTryCompileExec1149010363.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1149010363.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_STAT_HAS_ST_MTIM -O2      -o CMakeFiles/cmTryCompileExec1149010363.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1149010363
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1149010363.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1149010363.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1149010363 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C++ compiler has 'long long' compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2567226614/fast"
make -f CMakeFiles/cmTryCompileExec2567226614.dir/build.make CMakeFiles/cmTryCompileExec2567226614.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2567226614.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_LONG_LONG -O2      -o CMakeFiles/cmTryCompileExec2567226614.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2567226614
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2567226614.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2567226614.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2567226614 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for C type size macros compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec486850214/fast"
make -f CMakeFiles/cmTryCompileExec486850214.dir/build.make CMakeFiles/cmTryCompileExec486850214.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec486850214.dir/kwsysPlatformTestsC.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc  -DTEST_KWSYS_C_TYPE_MACROS -O2      -o CMakeFiles/cmTryCompileExec486850214.dir/kwsysPlatformTestsC.c.o   -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec486850214
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec486850214.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec486850214.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec486850214 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file sys/types.h exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3151738136/fast"
make -f CMakeFiles/cmTryCompileExec3151738136.dir/build.make CMakeFiles/cmTryCompileExec3151738136.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3151738136.dir/CheckIncludeFile.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3151738136.dir/CheckIncludeFile.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3151738136
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3151738136.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec3151738136.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3151738136 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file stdint.h exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec53509110/fast"
make -f CMakeFiles/cmTryCompileExec53509110.dir/build.make CMakeFiles/cmTryCompileExec53509110.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec53509110.dir/CheckIncludeFile.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec53509110.dir/CheckIncludeFile.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec53509110
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec53509110.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec53509110.dir/CheckIncludeFile.c.o  -o cmTryCompileExec53509110 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file stddef.h exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3374275996/fast"
make -f CMakeFiles/cmTryCompileExec3374275996.dir/build.make CMakeFiles/cmTryCompileExec3374275996.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3374275996.dir/CheckIncludeFile.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3374275996.dir/CheckIncludeFile.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3374275996
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3374275996.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec3374275996.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3374275996 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of char passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3838327257/fast"
make -f CMakeFiles/cmTryCompileExec3838327257.dir/build.make CMakeFiles/cmTryCompileExec3838327257.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3838327257.dir/KWSYS_SIZEOF_CHAR.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3838327257.dir/KWSYS_SIZEOF_CHAR.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/KWSYS_SIZEOF_CHAR.c
Linking C executable cmTryCompileExec3838327257
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3838327257.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec3838327257.dir/KWSYS_SIZEOF_CHAR.c.o  -o cmTryCompileExec3838327257 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Checking whether char is signed compiled and ran with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2163073899/fast"
make -f CMakeFiles/cmTryCompileExec2163073899.dir/build.make CMakeFiles/cmTryCompileExec2163073899.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2163073899.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CHAR_IS_SIGNED -O2      -o CMakeFiles/cmTryCompileExec2163073899.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2163073899
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2163073899.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2163073899.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2163073899 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if istream supports long long compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2601570215/fast"
make -f CMakeFiles/cmTryCompileExec2601570215.dir/build.make CMakeFiles/cmTryCompileExec2601570215.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2601570215.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_ISTREAM_LONG_LONG -O2      -o CMakeFiles/cmTryCompileExec2601570215.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2601570215
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2601570215.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2601570215.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2601570215 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if ostream supports long long compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec660175093/fast"
make -f CMakeFiles/cmTryCompileExec660175093.dir/build.make CMakeFiles/cmTryCompileExec660175093.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec660175093.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DKWSYS_IOS_HAVE_STD=1 -DKWSYS_IOS_USE_ANSI=1 -DTEST_KWSYS_IOS_HAS_OSTREAM_LONG_LONG -O2      -o CMakeFiles/cmTryCompileExec660175093.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec660175093
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec660175093.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec660175093.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec660175093 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ptrdiff_t in stddef.h compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec314308049/fast"
make -f CMakeFiles/cmTryCompileExec314308049.dir/build.make CMakeFiles/cmTryCompileExec314308049.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec314308049.dir/kwsysPlatformTestsC.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc  -DTEST_KWSYS_C_HAS_PTRDIFF_T -O2      -o CMakeFiles/cmTryCompileExec314308049.dir/kwsysPlatformTestsC.c.o   -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec314308049
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec314308049.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec314308049.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec314308049 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ssize_t in unistd.h compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2223593738/fast"
make -f CMakeFiles/cmTryCompileExec2223593738.dir/build.make CMakeFiles/cmTryCompileExec2223593738.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2223593738.dir/kwsysPlatformTestsC.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc  -DTEST_KWSYS_C_HAS_SSIZE_T -O2      -o CMakeFiles/cmTryCompileExec2223593738.dir/kwsysPlatformTestsC.c.o   -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec2223593738
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2223593738.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec2223593738.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec2223593738 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has setenv compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3881830202/fast"
make -f CMakeFiles/cmTryCompileExec3881830202.dir/build.make CMakeFiles/cmTryCompileExec3881830202.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3881830202.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_SETENV -O2      -o CMakeFiles/cmTryCompileExec3881830202.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3881830202
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3881830202.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3881830202.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3881830202 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has unsetenv compiled with the following output:
Change Dir: /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3636579200/fast"
make -f CMakeFiles/cmTryCompileExec3636579200.dir/build.make CMakeFiles/cmTryCompileExec3636579200.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3636579200.dir/kwsysPlatformTestsCXX.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++   -DTEST_KWSYS_CXX_HAS_UNSETENV -O2      -o CMakeFiles/cmTryCompileExec3636579200.dir/kwsysPlatformTestsCXX.cxx.o -c /source/cmake-2.8.10.2/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3636579200
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3636579200.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3636579200.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3636579200 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the function gethostbyname exists in the c passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1891585348/fast"
make -f CMakeFiles/cmTryCompileExec1891585348.dir/build.make CMakeFiles/cmTryCompileExec1891585348.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1891585348.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DCHECK_FUNCTION_EXISTS=gethostbyname   -o CMakeFiles/cmTryCompileExec1891585348.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1891585348
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1891585348.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DCHECK_FUNCTION_EXISTS=gethostbyname   -static-libgcc CMakeFiles/cmTryCompileExec1891585348.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1891585348 -rdynamic -lc 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function dlopen exists in the dl passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3759100661/fast"
make -f CMakeFiles/cmTryCompileExec3759100661.dir/build.make CMakeFiles/cmTryCompileExec3759100661.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3759100661.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DCHECK_FUNCTION_EXISTS=dlopen   -o CMakeFiles/cmTryCompileExec3759100661.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3759100661
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3759100661.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DCHECK_FUNCTION_EXISTS=dlopen   -static-libgcc CMakeFiles/cmTryCompileExec3759100661.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3759100661 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file features.h exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3641782749/fast"
make -f CMakeFiles/cmTryCompileExec3641782749.dir/build.make CMakeFiles/cmTryCompileExec3641782749.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3641782749.dir/CheckIncludeFile.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3641782749.dir/CheckIncludeFile.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3641782749
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3641782749.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3641782749.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3641782749 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files ;stdio.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1163899809/fast"
make -f CMakeFiles/cmTryCompileExec1163899809.dir/build.make CMakeFiles/cmTryCompileExec1163899809.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1163899809.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1163899809.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1163899809
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1163899809.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1163899809.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1163899809 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1252091749/fast"
make -f CMakeFiles/cmTryCompileExec1252091749.dir/build.make CMakeFiles/cmTryCompileExec1252091749.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1252091749.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1252091749.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1252091749
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1252091749.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1252091749.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1252091749 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4081473780/fast"
make -f CMakeFiles/cmTryCompileExec4081473780.dir/build.make CMakeFiles/cmTryCompileExec4081473780.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4081473780.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec4081473780.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4081473780
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4081473780.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4081473780.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4081473780 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1559364015/fast"
make -f CMakeFiles/cmTryCompileExec1559364015.dir/build.make CMakeFiles/cmTryCompileExec1559364015.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1559364015.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1559364015.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1559364015
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1559364015.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1559364015.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1559364015 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3551887761/fast"
make -f CMakeFiles/cmTryCompileExec3551887761.dir/build.make CMakeFiles/cmTryCompileExec3551887761.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3551887761.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3551887761.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3551887761
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3551887761.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3551887761.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3551887761 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1170777217/fast"
make -f CMakeFiles/cmTryCompileExec1170777217.dir/build.make CMakeFiles/cmTryCompileExec1170777217.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1170777217.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1170777217.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1170777217
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1170777217.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1170777217.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1170777217 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3009927140/fast"
make -f CMakeFiles/cmTryCompileExec3009927140.dir/build.make CMakeFiles/cmTryCompileExec3009927140.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3009927140.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3009927140.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3009927140
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3009927140.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3009927140.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3009927140 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1049960191/fast"
make -f CMakeFiles/cmTryCompileExec1049960191.dir/build.make CMakeFiles/cmTryCompileExec1049960191.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1049960191.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1049960191.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1049960191
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1049960191.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1049960191.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1049960191 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1762319313/fast"
make -f CMakeFiles/cmTryCompileExec1762319313.dir/build.make CMakeFiles/cmTryCompileExec1762319313.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1762319313.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1762319313.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1762319313
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1762319313.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1762319313.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1762319313 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3731053044/fast"
make -f CMakeFiles/cmTryCompileExec3731053044.dir/build.make CMakeFiles/cmTryCompileExec3731053044.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3731053044.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3731053044.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3731053044
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3731053044.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3731053044.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3731053044 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec432823657/fast"
make -f CMakeFiles/cmTryCompileExec432823657.dir/build.make CMakeFiles/cmTryCompileExec432823657.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec432823657.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec432823657.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec432823657
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec432823657.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec432823657.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec432823657 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2366898087/fast"
make -f CMakeFiles/cmTryCompileExec2366898087.dir/build.make CMakeFiles/cmTryCompileExec2366898087.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2366898087.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2366898087.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2366898087
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2366898087.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2366898087.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2366898087 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3778897157/fast"
make -f CMakeFiles/cmTryCompileExec3778897157.dir/build.make CMakeFiles/cmTryCompileExec3778897157.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3778897157.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3778897157.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3778897157
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3778897157.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3778897157.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3778897157 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3402668574/fast"
make -f CMakeFiles/cmTryCompileExec3402668574.dir/build.make CMakeFiles/cmTryCompileExec3402668574.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3402668574.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3402668574.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3402668574
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3402668574.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3402668574.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3402668574 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1636756198/fast"
make -f CMakeFiles/cmTryCompileExec1636756198.dir/build.make CMakeFiles/cmTryCompileExec1636756198.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1636756198.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1636756198.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1636756198
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1636756198.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1636756198.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1636756198 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1093849916/fast"
make -f CMakeFiles/cmTryCompileExec1093849916.dir/build.make CMakeFiles/cmTryCompileExec1093849916.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1093849916.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1093849916.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1093849916
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1093849916.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1093849916.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1093849916 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2853747982/fast"
make -f CMakeFiles/cmTryCompileExec2853747982.dir/build.make CMakeFiles/cmTryCompileExec2853747982.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2853747982.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2853747982.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2853747982
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2853747982.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2853747982.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2853747982 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec158609445/fast"
make -f CMakeFiles/cmTryCompileExec158609445.dir/build.make CMakeFiles/cmTryCompileExec158609445.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec158609445.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec158609445.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec158609445
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec158609445.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec158609445.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec158609445 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2999458402/fast"
make -f CMakeFiles/cmTryCompileExec2999458402.dir/build.make CMakeFiles/cmTryCompileExec2999458402.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2999458402.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2999458402.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2999458402
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2999458402.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2999458402.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2999458402 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2341028694/fast"
make -f CMakeFiles/cmTryCompileExec2341028694.dir/build.make CMakeFiles/cmTryCompileExec2341028694.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2341028694.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2341028694.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2341028694
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2341028694.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2341028694.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2341028694 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4066619610/fast"
make -f CMakeFiles/cmTryCompileExec4066619610.dir/build.make CMakeFiles/cmTryCompileExec4066619610.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4066619610.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec4066619610.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4066619610
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4066619610.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4066619610.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4066619610 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1578272381/fast"
make -f CMakeFiles/cmTryCompileExec1578272381.dir/build.make CMakeFiles/cmTryCompileExec1578272381.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1578272381.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1578272381.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1578272381
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1578272381.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1578272381.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1578272381 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1891724383/fast"
make -f CMakeFiles/cmTryCompileExec1891724383.dir/build.make CMakeFiles/cmTryCompileExec1891724383.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1891724383.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1891724383.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1891724383
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1891724383.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1891724383.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1891724383 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec362979937/fast"
make -f CMakeFiles/cmTryCompileExec362979937.dir/build.make CMakeFiles/cmTryCompileExec362979937.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec362979937.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec362979937.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec362979937
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec362979937.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec362979937.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec362979937 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1855836315/fast"
make -f CMakeFiles/cmTryCompileExec1855836315.dir/build.make CMakeFiles/cmTryCompileExec1855836315.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1855836315.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1855836315.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1855836315
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1855836315.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1855836315.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1855836315 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1235687869/fast"
make -f CMakeFiles/cmTryCompileExec1235687869.dir/build.make CMakeFiles/cmTryCompileExec1235687869.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1235687869.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1235687869.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1235687869
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1235687869.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1235687869.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1235687869 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3480980956/fast"
make -f CMakeFiles/cmTryCompileExec3480980956.dir/build.make CMakeFiles/cmTryCompileExec3480980956.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3480980956.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3480980956.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3480980956
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3480980956.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3480980956.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3480980956 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3445454389/fast"
make -f CMakeFiles/cmTryCompileExec3445454389.dir/build.make CMakeFiles/cmTryCompileExec3445454389.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3445454389.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3445454389.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3445454389
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3445454389.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3445454389.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3445454389 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec460694188/fast"
make -f CMakeFiles/cmTryCompileExec460694188.dir/build.make CMakeFiles/cmTryCompileExec460694188.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec460694188.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec460694188.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec460694188
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec460694188.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec460694188.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec460694188 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec145492238/fast"
make -f CMakeFiles/cmTryCompileExec145492238.dir/build.make CMakeFiles/cmTryCompileExec145492238.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec145492238.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec145492238.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec145492238
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec145492238.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec145492238.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec145492238 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2709980752/fast"
make -f CMakeFiles/cmTryCompileExec2709980752.dir/build.make CMakeFiles/cmTryCompileExec2709980752.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2709980752.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2709980752.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2709980752
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2709980752.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2709980752.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2709980752 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1192683768/fast"
make -f CMakeFiles/cmTryCompileExec1192683768.dir/build.make CMakeFiles/cmTryCompileExec1192683768.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1192683768.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1192683768.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1192683768
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1192683768.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1192683768.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1192683768 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec812447849/fast"
make -f CMakeFiles/cmTryCompileExec812447849.dir/build.make CMakeFiles/cmTryCompileExec812447849.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec812447849.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec812447849.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec812447849
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec812447849.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec812447849.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec812447849 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2568533867/fast"
make -f CMakeFiles/cmTryCompileExec2568533867.dir/build.make CMakeFiles/cmTryCompileExec2568533867.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2568533867.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2568533867.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2568533867
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2568533867.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2568533867.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2568533867 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2846065362/fast"
make -f CMakeFiles/cmTryCompileExec2846065362.dir/build.make CMakeFiles/cmTryCompileExec2846065362.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2846065362.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2846065362.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2846065362
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2846065362.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2846065362.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2846065362 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3076595102/fast"
make -f CMakeFiles/cmTryCompileExec3076595102.dir/build.make CMakeFiles/cmTryCompileExec3076595102.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3076595102.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3076595102.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3076595102
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3076595102.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3076595102.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3076595102 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2338682587/fast"
make -f CMakeFiles/cmTryCompileExec2338682587.dir/build.make CMakeFiles/cmTryCompileExec2338682587.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2338682587.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2338682587.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2338682587
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2338682587.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2338682587.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2338682587 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1484672483/fast"
make -f CMakeFiles/cmTryCompileExec1484672483.dir/build.make CMakeFiles/cmTryCompileExec1484672483.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1484672483.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1484672483.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1484672483
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1484672483.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1484672483.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1484672483 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2583646396/fast"
make -f CMakeFiles/cmTryCompileExec2583646396.dir/build.make CMakeFiles/cmTryCompileExec2583646396.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2583646396.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2583646396.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2583646396
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2583646396.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2583646396.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2583646396 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h;libgen.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2748534726/fast"
make -f CMakeFiles/cmTryCompileExec2748534726.dir/build.make CMakeFiles/cmTryCompileExec2748534726.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2748534726.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2748534726.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2748534726
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2748534726.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2748534726.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2748534726 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1291169712/fast"
make -f CMakeFiles/cmTryCompileExec1291169712.dir/build.make CMakeFiles/cmTryCompileExec1291169712.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1291169712.dir/SIZEOF_SIZE_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1291169712.dir/SIZEOF_SIZE_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_SIZE_T.c
Linking C executable cmTryCompileExec1291169712
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1291169712.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1291169712.dir/SIZEOF_SIZE_T.c.o  -o cmTryCompileExec1291169712 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2170799093/fast"
make -f CMakeFiles/cmTryCompileExec2170799093.dir/build.make CMakeFiles/cmTryCompileExec2170799093.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2170799093.dir/SIZEOF_SSIZE_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2170799093.dir/SIZEOF_SSIZE_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_SSIZE_T.c
Linking C executable cmTryCompileExec2170799093
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2170799093.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2170799093.dir/SIZEOF_SSIZE_T.c.o  -o cmTryCompileExec2170799093 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2653554922/fast"
make -f CMakeFiles/cmTryCompileExec2653554922.dir/build.make CMakeFiles/cmTryCompileExec2653554922.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2653554922.dir/SIZEOF_LONG_LONG.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2653554922.dir/SIZEOF_LONG_LONG.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG_LONG.c
Linking C executable cmTryCompileExec2653554922
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2653554922.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2653554922.dir/SIZEOF_LONG_LONG.c.o  -o cmTryCompileExec2653554922 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2903363687/fast"
make -f CMakeFiles/cmTryCompileExec2903363687.dir/build.make CMakeFiles/cmTryCompileExec2903363687.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2903363687.dir/SIZEOF_LONG.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2903363687.dir/SIZEOF_LONG.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_LONG.c
Linking C executable cmTryCompileExec2903363687
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2903363687.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2903363687.dir/SIZEOF_LONG.c.o  -o cmTryCompileExec2903363687 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of time_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1780098511/fast"
make -f CMakeFiles/cmTryCompileExec1780098511.dir/build.make CMakeFiles/cmTryCompileExec1780098511.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1780098511.dir/SIZEOF_TIME_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1780098511.dir/SIZEOF_TIME_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_TIME_T.c
Linking C executable cmTryCompileExec1780098511
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1780098511.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1780098511.dir/SIZEOF_TIME_T.c.o  -o cmTryCompileExec1780098511 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the basename exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2463792870/fast"
make -f CMakeFiles/cmTryCompileExec2463792870.dir/build.make CMakeFiles/cmTryCompileExec2463792870.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2463792870.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2463792870.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2463792870
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2463792870.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2463792870.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2463792870 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef basename
  return ((int*)(&basename))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the socket exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2184016862/fast"
make -f CMakeFiles/cmTryCompileExec2184016862.dir/build.make CMakeFiles/cmTryCompileExec2184016862.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2184016862.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2184016862.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2184016862
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2184016862.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2184016862.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2184016862 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef socket
  return ((int*)(&socket))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the poll exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2930365559/fast"
make -f CMakeFiles/cmTryCompileExec2930365559.dir/build.make CMakeFiles/cmTryCompileExec2930365559.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2930365559.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2930365559.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2930365559
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2930365559.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2930365559.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2930365559 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef poll
  return ((int*)(&poll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the select exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3722316388/fast"
make -f CMakeFiles/cmTryCompileExec3722316388.dir/build.make CMakeFiles/cmTryCompileExec3722316388.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3722316388.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3722316388.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3722316388
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3722316388.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3722316388.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3722316388 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef select
  return ((int*)(&select))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strdup exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2867849789/fast"
make -f CMakeFiles/cmTryCompileExec2867849789.dir/build.make CMakeFiles/cmTryCompileExec2867849789.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2867849789.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2867849789.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2867849789
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2867849789.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2867849789.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2867849789 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strdup
  return ((int*)(&strdup))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strstr exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3573831908/fast"
make -f CMakeFiles/cmTryCompileExec3573831908.dir/build.make CMakeFiles/cmTryCompileExec3573831908.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3573831908.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3573831908.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3573831908
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3573831908.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3573831908.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3573831908 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strstr
  return ((int*)(&strstr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtok_r exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2463709854/fast"
make -f CMakeFiles/cmTryCompileExec2463709854.dir/build.make CMakeFiles/cmTryCompileExec2463709854.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2463709854.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2463709854.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2463709854
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2463709854.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2463709854.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2463709854 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtok_r
  return ((int*)(&strtok_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strftime exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2702408729/fast"
make -f CMakeFiles/cmTryCompileExec2702408729.dir/build.make CMakeFiles/cmTryCompileExec2702408729.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2702408729.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2702408729.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2702408729
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2702408729.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2702408729.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2702408729 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strftime
  return ((int*)(&strftime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the uname exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec388293926/fast"
make -f CMakeFiles/cmTryCompileExec388293926.dir/build.make CMakeFiles/cmTryCompileExec388293926.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec388293926.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec388293926.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec388293926
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec388293926.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec388293926.dir/CheckSymbolExists.c.o  -o cmTryCompileExec388293926 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef uname
  return ((int*)(&uname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strcasecmp exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1392812136/fast"
make -f CMakeFiles/cmTryCompileExec1392812136.dir/build.make CMakeFiles/cmTryCompileExec1392812136.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1392812136.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1392812136.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1392812136
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1392812136.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1392812136.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1392812136 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strcasecmp
  return ((int*)(&strcasecmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3288571129/fast"
make -f CMakeFiles/cmTryCompileExec3288571129.dir/build.make CMakeFiles/cmTryCompileExec3288571129.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3288571129.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3288571129.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3288571129
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3288571129.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3288571129.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3288571129 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr
  return ((int*)(&gethostbyaddr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gettimeofday exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4139166516/fast"
make -f CMakeFiles/cmTryCompileExec4139166516.dir/build.make CMakeFiles/cmTryCompileExec4139166516.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4139166516.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec4139166516.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4139166516
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4139166516.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4139166516.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4139166516 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gettimeofday
  return ((int*)(&gettimeofday))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_addr exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2600706036/fast"
make -f CMakeFiles/cmTryCompileExec2600706036.dir/build.make CMakeFiles/cmTryCompileExec2600706036.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2600706036.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2600706036.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2600706036
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2600706036.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2600706036.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2600706036 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_addr
  return ((int*)(&inet_addr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_pton exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1053746575/fast"
make -f CMakeFiles/cmTryCompileExec1053746575.dir/build.make CMakeFiles/cmTryCompileExec1053746575.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1053746575.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1053746575.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1053746575
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1053746575.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1053746575.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1053746575 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_pton
  return ((int*)(&inet_pton))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_ntoa exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1919308704/fast"
make -f CMakeFiles/cmTryCompileExec1919308704.dir/build.make CMakeFiles/cmTryCompileExec1919308704.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1919308704.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1919308704.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1919308704
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1919308704.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1919308704.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1919308704 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_ntoa
  return ((int*)(&inet_ntoa))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcsetattr exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec963713889/fast"
make -f CMakeFiles/cmTryCompileExec963713889.dir/build.make CMakeFiles/cmTryCompileExec963713889.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec963713889.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec963713889.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec963713889
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec963713889.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec963713889.dir/CheckSymbolExists.c.o  -o cmTryCompileExec963713889 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcsetattr
  return ((int*)(&tcsetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcgetattr exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2975742678/fast"
make -f CMakeFiles/cmTryCompileExec2975742678.dir/build.make CMakeFiles/cmTryCompileExec2975742678.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2975742678.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2975742678.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2975742678
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2975742678.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2975742678.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2975742678 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcgetattr
  return ((int*)(&tcgetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the perror exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4005100582/fast"
make -f CMakeFiles/cmTryCompileExec4005100582.dir/build.make CMakeFiles/cmTryCompileExec4005100582.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4005100582.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec4005100582.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4005100582
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4005100582.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4005100582.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4005100582 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef perror
  return ((int*)(&perror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setvbuf exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec163568726/fast"
make -f CMakeFiles/cmTryCompileExec163568726.dir/build.make CMakeFiles/cmTryCompileExec163568726.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec163568726.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec163568726.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec163568726
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec163568726.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec163568726.dir/CheckSymbolExists.c.o  -o cmTryCompileExec163568726 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setvbuf
  return ((int*)(&setvbuf))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigsetjmp exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec987333302/fast"
make -f CMakeFiles/cmTryCompileExec987333302.dir/build.make CMakeFiles/cmTryCompileExec987333302.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec987333302.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec987333302.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec987333302
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec987333302.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec987333302.dir/CheckSymbolExists.c.o  -o cmTryCompileExec987333302 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigsetjmp
  return ((int*)(&sigsetjmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getpwuid exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3157056204/fast"
make -f CMakeFiles/cmTryCompileExec3157056204.dir/build.make CMakeFiles/cmTryCompileExec3157056204.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3157056204.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3157056204.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3157056204
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3157056204.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3157056204.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3157056204 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getpwuid
  return ((int*)(&getpwuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the geteuid exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3625709432/fast"
make -f CMakeFiles/cmTryCompileExec3625709432.dir/build.make CMakeFiles/cmTryCompileExec3625709432.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3625709432.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3625709432.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3625709432
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3625709432.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3625709432.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3625709432 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef geteuid
  return ((int*)(&geteuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the utime exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3005106917/fast"
make -f CMakeFiles/cmTryCompileExec3005106917.dir/build.make CMakeFiles/cmTryCompileExec3005106917.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3005106917.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3005106917.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3005106917
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3005106917.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3005106917.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3005106917 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef utime
  return ((int*)(&utime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gmtime_r exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1949110952/fast"
make -f CMakeFiles/cmTryCompileExec1949110952.dir/build.make CMakeFiles/cmTryCompileExec1949110952.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1949110952.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1949110952.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1949110952
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1949110952.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1949110952.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1949110952 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gmtime_r
  return ((int*)(&gmtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the localtime_r exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4292924919/fast"
make -f CMakeFiles/cmTryCompileExec4292924919.dir/build.make CMakeFiles/cmTryCompileExec4292924919.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4292924919.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec4292924919.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4292924919
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4292924919.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4292924919.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4292924919 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef localtime_r
  return ((int*)(&localtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4229668602/fast"
make -f CMakeFiles/cmTryCompileExec4229668602.dir/build.make CMakeFiles/cmTryCompileExec4229668602.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4229668602.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec4229668602.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4229668602
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4229668602.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4229668602.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4229668602 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname
  return ((int*)(&gethostbyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname_r exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2771353109/fast"
make -f CMakeFiles/cmTryCompileExec2771353109.dir/build.make CMakeFiles/cmTryCompileExec2771353109.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2771353109.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2771353109.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2771353109
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2771353109.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2771353109.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2771353109 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname_r
  return ((int*)(&gethostbyname_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr_r exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3265825810/fast"
make -f CMakeFiles/cmTryCompileExec3265825810.dir/build.make CMakeFiles/cmTryCompileExec3265825810.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3265825810.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3265825810.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3265825810
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3265825810.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3265825810.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3265825810 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr_r
  return ((int*)(&gethostbyaddr_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the signal exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3012984537/fast"
make -f CMakeFiles/cmTryCompileExec3012984537.dir/build.make CMakeFiles/cmTryCompileExec3012984537.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3012984537.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3012984537.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3012984537
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3012984537.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3012984537.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3012984537 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef signal
  return ((int*)(&signal))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIGALRM exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1636788276/fast"
make -f CMakeFiles/cmTryCompileExec1636788276.dir/build.make CMakeFiles/cmTryCompileExec1636788276.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1636788276.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1636788276.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1636788276
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1636788276.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1636788276.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1636788276 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIGALRM
  return ((int*)(&SIGALRM))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtoll exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2336619413/fast"
make -f CMakeFiles/cmTryCompileExec2336619413.dir/build.make CMakeFiles/cmTryCompileExec2336619413.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2336619413.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2336619413.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2336619413
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2336619413.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2336619413.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2336619413 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtoll
  return ((int*)(&strtoll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strerror_r exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3311381252/fast"
make -f CMakeFiles/cmTryCompileExec3311381252.dir/build.make CMakeFiles/cmTryCompileExec3311381252.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3311381252.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3311381252.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3311381252
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3311381252.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3311381252.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3311381252 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strerror_r
  return ((int*)(&strerror_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the siginterrupt exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1950513615/fast"
make -f CMakeFiles/cmTryCompileExec1950513615.dir/build.make CMakeFiles/cmTryCompileExec1950513615.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1950513615.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1950513615.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1950513615
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1950513615.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1950513615.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1950513615 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef siginterrupt
  return ((int*)(&siginterrupt))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the fork exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2644708443/fast"
make -f CMakeFiles/cmTryCompileExec2644708443.dir/build.make CMakeFiles/cmTryCompileExec2644708443.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2644708443.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2644708443.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2644708443
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2644708443.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2644708443.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2644708443 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef fork
  return ((int*)(&fork))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the pipe exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1920377856/fast"
make -f CMakeFiles/cmTryCompileExec1920377856.dir/build.make CMakeFiles/cmTryCompileExec1920377856.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1920377856.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1920377856.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1920377856
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1920377856.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1920377856.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1920377856 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef pipe
  return ((int*)(&pipe))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the ftruncate exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec808915249/fast"
make -f CMakeFiles/cmTryCompileExec808915249.dir/build.make CMakeFiles/cmTryCompileExec808915249.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec808915249.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec808915249.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec808915249
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec808915249.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec808915249.dir/CheckSymbolExists.c.o  -o cmTryCompileExec808915249 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef ftruncate
  return ((int*)(&ftruncate))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getprotobyname exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4275595413/fast"
make -f CMakeFiles/cmTryCompileExec4275595413.dir/build.make CMakeFiles/cmTryCompileExec4275595413.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4275595413.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec4275595413.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4275595413
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4275595413.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec4275595413.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4275595413 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getprotobyname
  return ((int*)(&getprotobyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getrlimit exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1356524879/fast"
make -f CMakeFiles/cmTryCompileExec1356524879.dir/build.make CMakeFiles/cmTryCompileExec1356524879.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1356524879.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1356524879.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1356524879
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1356524879.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1356524879.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1356524879 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getrlimit
  return ((int*)(&getrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setlocale exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3193354900/fast"
make -f CMakeFiles/cmTryCompileExec3193354900.dir/build.make CMakeFiles/cmTryCompileExec3193354900.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3193354900.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec3193354900.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3193354900
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3193354900.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec3193354900.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3193354900 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setlocale
  return ((int*)(&setlocale))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setrlimit exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec131674298/fast"
make -f CMakeFiles/cmTryCompileExec131674298.dir/build.make CMakeFiles/cmTryCompileExec131674298.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec131674298.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec131674298.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec131674298
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec131674298.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec131674298.dir/CheckSymbolExists.c.o  -o cmTryCompileExec131674298 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setrlimit
  return ((int*)(&setrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigaction exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec283357227/fast"
make -f CMakeFiles/cmTryCompileExec283357227.dir/build.make CMakeFiles/cmTryCompileExec283357227.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec283357227.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec283357227.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec283357227
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec283357227.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec283357227.dir/CheckSymbolExists.c.o  -o cmTryCompileExec283357227 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <signal.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigaction
  return ((int*)(&sigaction))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing Curl Test HAVE_O_NONBLOCK passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2203185307/fast"
make -f CMakeFiles/cmTryCompileExec2203185307.dir/build.make CMakeFiles/cmTryCompileExec2203185307.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2203185307.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_O_NONBLOCK   -o CMakeFiles/cmTryCompileExec2203185307.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2203185307
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2203185307.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_O_NONBLOCK   -static-libgcc CMakeFiles/cmTryCompileExec2203185307.dir/CurlTests.c.o  -o cmTryCompileExec2203185307 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test TIME_WITH_SYS_TIME passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1774008433/fast"
make -f CMakeFiles/cmTryCompileExec1774008433.dir/build.make CMakeFiles/cmTryCompileExec1774008433.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1774008433.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DTIME_WITH_SYS_TIME   -o CMakeFiles/cmTryCompileExec1774008433.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1774008433
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1774008433.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DTIME_WITH_SYS_TIME   -static-libgcc CMakeFiles/cmTryCompileExec1774008433.dir/CurlTests.c.o  -o cmTryCompileExec1774008433 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8 passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3792218089/fast"
make -f CMakeFiles/cmTryCompileExec3792218089.dir/build.make CMakeFiles/cmTryCompileExec3792218089.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3792218089.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_GETHOSTBYADDR_R_8   -o CMakeFiles/cmTryCompileExec3792218089.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3792218089
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3792218089.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_GETHOSTBYADDR_R_8   -static-libgcc CMakeFiles/cmTryCompileExec3792218089.dir/CurlTests.c.o  -o cmTryCompileExec3792218089 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8_REENTRANT passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1818659724/fast"
make -f CMakeFiles/cmTryCompileExec1818659724.dir/build.make CMakeFiles/cmTryCompileExec1818659724.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1818659724.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -o CMakeFiles/cmTryCompileExec1818659724.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1818659724
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1818659724.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -static-libgcc CMakeFiles/cmTryCompileExec1818659724.dir/CurlTests.c.o  -o cmTryCompileExec1818659724 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6 passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1055214141/fast"
make -f CMakeFiles/cmTryCompileExec1055214141.dir/build.make CMakeFiles/cmTryCompileExec1055214141.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1055214141.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_GETHOSTBYNAME_R_6   -o CMakeFiles/cmTryCompileExec1055214141.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1055214141
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1055214141.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_GETHOSTBYNAME_R_6   -static-libgcc CMakeFiles/cmTryCompileExec1055214141.dir/CurlTests.c.o  -o cmTryCompileExec1055214141 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6_REENTRANT passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2608876914/fast"
make -f CMakeFiles/cmTryCompileExec2608876914.dir/build.make CMakeFiles/cmTryCompileExec2608876914.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2608876914.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -o CMakeFiles/cmTryCompileExec2608876914.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2608876914
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2608876914.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -static-libgcc CMakeFiles/cmTryCompileExec2608876914.dir/CurlTests.c.o  -o cmTryCompileExec2608876914 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_SOCKLEN_T passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2050560220/fast"
make -f CMakeFiles/cmTryCompileExec2050560220.dir/build.make CMakeFiles/cmTryCompileExec2050560220.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2050560220.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_SOCKLEN_T   -o CMakeFiles/cmTryCompileExec2050560220.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2050560220
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2050560220.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_SOCKLEN_T   -static-libgcc CMakeFiles/cmTryCompileExec2050560220.dir/CurlTests.c.o  -o cmTryCompileExec2050560220 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_IN_ADDR_T passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2196624016/fast"
make -f CMakeFiles/cmTryCompileExec2196624016.dir/build.make CMakeFiles/cmTryCompileExec2196624016.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2196624016.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_IN_ADDR_T   -o CMakeFiles/cmTryCompileExec2196624016.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2196624016
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2196624016.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_IN_ADDR_T   -static-libgcc CMakeFiles/cmTryCompileExec2196624016.dir/CurlTests.c.o  -o cmTryCompileExec2196624016 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test STDC_HEADERS passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2328168341/fast"
make -f CMakeFiles/cmTryCompileExec2328168341.dir/build.make CMakeFiles/cmTryCompileExec2328168341.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2328168341.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DSTDC_HEADERS   -o CMakeFiles/cmTryCompileExec2328168341.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2328168341
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2328168341.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DSTDC_HEADERS   -static-libgcc CMakeFiles/cmTryCompileExec2328168341.dir/CurlTests.c.o  -o cmTryCompileExec2328168341 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test RETSIGTYPE_TEST passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2435786752/fast"
make -f CMakeFiles/cmTryCompileExec2435786752.dir/build.make CMakeFiles/cmTryCompileExec2435786752.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2435786752.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DRETSIGTYPE_TEST   -o CMakeFiles/cmTryCompileExec2435786752.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2435786752
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2435786752.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DRETSIGTYPE_TEST   -static-libgcc CMakeFiles/cmTryCompileExec2435786752.dir/CurlTests.c.o  -o cmTryCompileExec2435786752 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETADDRINFO passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec998008563/fast"
make -f CMakeFiles/cmTryCompileExec998008563.dir/build.make CMakeFiles/cmTryCompileExec998008563.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec998008563.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_GETADDRINFO   -o CMakeFiles/cmTryCompileExec998008563.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
/source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c: In function ‘main’:
/source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c:405:5: warning: incompatible implicit declaration of built-in function ‘memset’ [enabled by default]
Linking C executable cmTryCompileExec998008563
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec998008563.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_GETADDRINFO   -static-libgcc CMakeFiles/cmTryCompileExec998008563.dir/CurlTests.c.o  -o cmTryCompileExec998008563 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_FILE_OFFSET_BITS passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1070867421/fast"
make -f CMakeFiles/cmTryCompileExec1070867421.dir/build.make CMakeFiles/cmTryCompileExec1070867421.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1070867421.dir/CurlTests.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_FILE_OFFSET_BITS   -o CMakeFiles/cmTryCompileExec1070867421.dir/CurlTests.c.o   -c /source/cmake-2.8.10.2/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1070867421
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1070867421.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_FILE_OFFSET_BITS   -static-libgcc CMakeFiles/cmTryCompileExec1070867421.dir/CurlTests.c.o  -o cmTryCompileExec1070867421 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Determining size of curl_off_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2998755773/fast"
make -f CMakeFiles/cmTryCompileExec2998755773.dir/build.make CMakeFiles/cmTryCompileExec2998755773.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2998755773.dir/SIZEOF_CURL_OFF_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -D_FILE_OFFSET_BITS=64   -o CMakeFiles/cmTryCompileExec2998755773.dir/SIZEOF_CURL_OFF_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_CURL_OFF_T.c
Linking C executable cmTryCompileExec2998755773
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2998755773.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -D_FILE_OFFSET_BITS=64   -static-libgcc CMakeFiles/cmTryCompileExec2998755773.dir/SIZEOF_CURL_OFF_T.c.o  -o cmTryCompileExec2998755773 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test curl_cv_recv succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3738956294/fast"
make -f CMakeFiles/cmTryCompileExec3738956294.dir/build.make CMakeFiles/cmTryCompileExec3738956294.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3738956294.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -Dcurl_cv_recv   -o CMakeFiles/cmTryCompileExec3738956294.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3738956294
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3738956294.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -Dcurl_cv_recv   -static-libgcc CMakeFiles/cmTryCompileExec3738956294.dir/src.c.o  -o cmTryCompileExec3738956294 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>

#define __unused5 1

int main() { recv(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test int recv(int, void *, size_t, int) (curl_cv_func_recv_test) succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3304242102/fast"
make -f CMakeFiles/cmTryCompileExec3304242102.dir/build.make CMakeFiles/cmTryCompileExec3304242102.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3304242102.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -Dcurl_cv_func_recv_test   -o CMakeFiles/cmTryCompileExec3304242102.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3304242102
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3304242102.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -Dcurl_cv_func_recv_test   -static-libgcc CMakeFiles/cmTryCompileExec3304242102.dir/src.c.o  -o cmTryCompileExec3304242102 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  recv(int, void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    void * buf=0;
                    size_t len=0;
                    int flags=0;
                    int res = recv(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test curl_cv_send succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3996906333/fast"
make -f CMakeFiles/cmTryCompileExec3996906333.dir/build.make CMakeFiles/cmTryCompileExec3996906333.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3996906333.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -Dcurl_cv_send   -o CMakeFiles/cmTryCompileExec3996906333.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3996906333
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3996906333.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -Dcurl_cv_send   -static-libgcc CMakeFiles/cmTryCompileExec3996906333.dir/src.c.o  -o cmTryCompileExec3996906333 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  recv(int, void *, size_t, int);
#define __unused5 1

int main() { send(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test int send(int, const void *, size_t, int) (curl_cv_func_send_test) succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2057250912/fast"
make -f CMakeFiles/cmTryCompileExec2057250912.dir/build.make CMakeFiles/cmTryCompileExec2057250912.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2057250912.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -Dcurl_cv_func_send_test   -o CMakeFiles/cmTryCompileExec2057250912.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2057250912
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2057250912.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -Dcurl_cv_func_send_test   -static-libgcc CMakeFiles/cmTryCompileExec2057250912.dir/src.c.o  -o cmTryCompileExec2057250912 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  send(int, const void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    const void * buf=0;
                    size_t len=0;
                    int flags=0;
                    int res = send(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test HAVE_MSG_NOSIGNAL succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3722157294/fast"
make -f CMakeFiles/cmTryCompileExec3722157294.dir/build.make CMakeFiles/cmTryCompileExec3722157294.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3722157294.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_MSG_NOSIGNAL   -o CMakeFiles/cmTryCompileExec3722157294.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c:12:0: warning: "__unused5" redefined [enabled by default]
/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c:8:0: note: this is the location of the previous definition
Linking C executable cmTryCompileExec3722157294
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3722157294.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_MSG_NOSIGNAL   -static-libgcc CMakeFiles/cmTryCompileExec3722157294.dir/src.c.o  -o cmTryCompileExec3722157294 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern int  send(int, const void *, size_t, int);
#define __unused5

#include <sys/types.h>
#include <sys/socket.h>
#define __unused5 1

int main() { int flag = MSG_NOSIGNAL ; return 0; }
Performing C SOURCE FILE Test HAVE_STRUCT_TIMEVAL succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2798858536/fast"
make -f CMakeFiles/cmTryCompileExec2798858536.dir/build.make CMakeFiles/cmTryCompileExec2798858536.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2798858536.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_STRUCT_TIMEVAL   -o CMakeFiles/cmTryCompileExec2798858536.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2798858536
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2798858536.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_STRUCT_TIMEVAL   -static-libgcc CMakeFiles/cmTryCompileExec2798858536.dir/src.c.o  -o cmTryCompileExec2798858536 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <time.h>
#define __unused5 1

int main() { struct timeval ts;
ts.tv_sec  = 0;
ts.tv_usec = 0 ; return 0; }
Determining size of sig_atomic_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2363582742/fast"
make -f CMakeFiles/cmTryCompileExec2363582742.dir/build.make CMakeFiles/cmTryCompileExec2363582742.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2363582742.dir/SIZEOF_SIG_ATOMIC_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2363582742.dir/SIZEOF_SIG_ATOMIC_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_SIG_ATOMIC_T.c
Linking C executable cmTryCompileExec2363582742
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2363582742.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec2363582742.dir/SIZEOF_SIG_ATOMIC_T.c.o  -o cmTryCompileExec2363582742 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_SIG_ATOMIC_T_NOT_VOLATILE succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3506103263/fast"
make -f CMakeFiles/cmTryCompileExec3506103263.dir/build.make CMakeFiles/cmTryCompileExec3506103263.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3506103263.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -o CMakeFiles/cmTryCompileExec3506103263.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3506103263
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3506103263.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -static-libgcc CMakeFiles/cmTryCompileExec3506103263.dir/src.c.o  -o cmTryCompileExec3506103263 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <signal.h>

int main() { static volatile sig_atomic_t dummy = 0 ; return 0; }
Determining size of struct sockaddr_storage passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1431966740/fast"
make -f CMakeFiles/cmTryCompileExec1431966740.dir/build.make CMakeFiles/cmTryCompileExec1431966740.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1431966740.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1431966740.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_STRUCT_SOCKADDR_STORAGE.c
Linking C executable cmTryCompileExec1431966740
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1431966740.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc    -O2      -static-libgcc CMakeFiles/cmTryCompileExec1431966740.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o  -o cmTryCompileExec1431966740 -rdynamic -ldl 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_DIRENT_H succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec393936089/fast"
make -f CMakeFiles/cmTryCompileExec393936089.dir/build.make CMakeFiles/cmTryCompileExec393936089.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec393936089.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_DIRENT_H   -o CMakeFiles/cmTryCompileExec393936089.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec393936089
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec393936089.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_DIRENT_H   -static-libgcc CMakeFiles/cmTryCompileExec393936089.dir/src.c.o  -o cmTryCompileExec393936089 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <dirent.h>

int main()
{
   static DIR * tmp;
   if (sizeof(tmp))
      return 0;
  return 0;
}

Determining if files sys/types.h;ctype.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3879741850/fast"
make -f CMakeFiles/cmTryCompileExec3879741850.dir/build.make CMakeFiles/cmTryCompileExec3879741850.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3879741850.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3879741850.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3879741850
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3879741850.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3879741850.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3879741850 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3838769527/fast"
make -f CMakeFiles/cmTryCompileExec3838769527.dir/build.make CMakeFiles/cmTryCompileExec3838769527.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3838769527.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3838769527.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3838769527
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3838769527.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3838769527.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3838769527 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4221897122/fast"
make -f CMakeFiles/cmTryCompileExec4221897122.dir/build.make CMakeFiles/cmTryCompileExec4221897122.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4221897122.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec4221897122.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4221897122
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4221897122.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec4221897122.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4221897122 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3205760734/fast"
make -f CMakeFiles/cmTryCompileExec3205760734.dir/build.make CMakeFiles/cmTryCompileExec3205760734.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3205760734.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3205760734.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3205760734
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3205760734.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3205760734.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3205760734 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3862525336/fast"
make -f CMakeFiles/cmTryCompileExec3862525336.dir/build.make CMakeFiles/cmTryCompileExec3862525336.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3862525336.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3862525336.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3862525336
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3862525336.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3862525336.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3862525336 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2826756966/fast"
make -f CMakeFiles/cmTryCompileExec2826756966.dir/build.make CMakeFiles/cmTryCompileExec2826756966.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2826756966.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2826756966.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2826756966
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2826756966.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2826756966.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2826756966 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3375290696/fast"
make -f CMakeFiles/cmTryCompileExec3375290696.dir/build.make CMakeFiles/cmTryCompileExec3375290696.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3375290696.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3375290696.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3375290696
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3375290696.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3375290696.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3375290696 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2979913945/fast"
make -f CMakeFiles/cmTryCompileExec2979913945.dir/build.make CMakeFiles/cmTryCompileExec2979913945.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2979913945.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2979913945.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2979913945
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2979913945.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2979913945.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2979913945 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1367690030/fast"
make -f CMakeFiles/cmTryCompileExec1367690030.dir/build.make CMakeFiles/cmTryCompileExec1367690030.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1367690030.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1367690030.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1367690030
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1367690030.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1367690030.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1367690030 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1694993069/fast"
make -f CMakeFiles/cmTryCompileExec1694993069.dir/build.make CMakeFiles/cmTryCompileExec1694993069.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1694993069.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1694993069.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1694993069
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1694993069.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1694993069.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1694993069 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec259519978/fast"
make -f CMakeFiles/cmTryCompileExec259519978.dir/build.make CMakeFiles/cmTryCompileExec259519978.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec259519978.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec259519978.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec259519978
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec259519978.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec259519978.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec259519978 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3941778912/fast"
make -f CMakeFiles/cmTryCompileExec3941778912.dir/build.make CMakeFiles/cmTryCompileExec3941778912.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3941778912.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3941778912.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3941778912
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3941778912.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3941778912.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3941778912 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1847585877/fast"
make -f CMakeFiles/cmTryCompileExec1847585877.dir/build.make CMakeFiles/cmTryCompileExec1847585877.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1847585877.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1847585877.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1847585877
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1847585877.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1847585877.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1847585877 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec290715702/fast"
make -f CMakeFiles/cmTryCompileExec290715702.dir/build.make CMakeFiles/cmTryCompileExec290715702.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec290715702.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec290715702.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec290715702
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec290715702.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec290715702.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec290715702 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec918252908/fast"
make -f CMakeFiles/cmTryCompileExec918252908.dir/build.make CMakeFiles/cmTryCompileExec918252908.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec918252908.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec918252908.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec918252908
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec918252908.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec918252908.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec918252908 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3699131998/fast"
make -f CMakeFiles/cmTryCompileExec3699131998.dir/build.make CMakeFiles/cmTryCompileExec3699131998.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3699131998.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3699131998.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3699131998
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3699131998.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3699131998.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3699131998 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1796479344/fast"
make -f CMakeFiles/cmTryCompileExec1796479344.dir/build.make CMakeFiles/cmTryCompileExec1796479344.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1796479344.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1796479344.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1796479344
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1796479344.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1796479344.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1796479344 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h;wctype.h exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4268015764/fast"
make -f CMakeFiles/cmTryCompileExec4268015764.dir/build.make CMakeFiles/cmTryCompileExec4268015764.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4268015764.dir/CheckIncludeFiles.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec4268015764.dir/CheckIncludeFiles.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec4268015764
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4268015764.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec4268015764.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec4268015764 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test SAFE_TO_DEFINE_EXTENSIONS succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1066993238/fast"
make -f CMakeFiles/cmTryCompileExec1066993238.dir/build.make CMakeFiles/cmTryCompileExec1066993238.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1066993238.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DSAFE_TO_DEFINE_EXTENSIONS   -o CMakeFiles/cmTryCompileExec1066993238.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1066993238
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1066993238.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DSAFE_TO_DEFINE_EXTENSIONS   -static-libgcc CMakeFiles/cmTryCompileExec1066993238.dir/src.c.o  -o cmTryCompileExec1066993238 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#define __EXTENSIONS__ 1
   
   int main() { return 0;}
Determining if the function chown exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4082593111/fast"
make -f CMakeFiles/cmTryCompileExec4082593111.dir/build.make CMakeFiles/cmTryCompileExec4082593111.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4082593111.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin   -o CMakeFiles/cmTryCompileExec4082593111.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4082593111
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4082593111.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=chown  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec4082593111.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4082593111 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function chroot exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3311380819/fast"
make -f CMakeFiles/cmTryCompileExec3311380819.dir/build.make CMakeFiles/cmTryCompileExec3311380819.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3311380819.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin   -o CMakeFiles/cmTryCompileExec3311380819.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3311380819
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3311380819.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=chroot  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3311380819.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3311380819 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function ctime_r exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3135387339/fast"
make -f CMakeFiles/cmTryCompileExec3135387339.dir/build.make CMakeFiles/cmTryCompileExec3135387339.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3135387339.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3135387339.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3135387339
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3135387339.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=ctime_r  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3135387339.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3135387339 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fchdir exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1692758953/fast"
make -f CMakeFiles/cmTryCompileExec1692758953.dir/build.make CMakeFiles/cmTryCompileExec1692758953.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1692758953.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec1692758953.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1692758953
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1692758953.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fchdir  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1692758953.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1692758953 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fchmod exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2144779631/fast"
make -f CMakeFiles/cmTryCompileExec2144779631.dir/build.make CMakeFiles/cmTryCompileExec2144779631.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2144779631.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin   -o CMakeFiles/cmTryCompileExec2144779631.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2144779631
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2144779631.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fchmod  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2144779631.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2144779631 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fchown exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3793903866/fast"
make -f CMakeFiles/cmTryCompileExec3793903866.dir/build.make CMakeFiles/cmTryCompileExec3793903866.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3793903866.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec3793903866.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3793903866
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3793903866.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fchown  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3793903866.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3793903866 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fcntl exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec974479650/fast"
make -f CMakeFiles/cmTryCompileExec974479650.dir/build.make CMakeFiles/cmTryCompileExec974479650.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec974479650.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin   -o CMakeFiles/cmTryCompileExec974479650.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec974479650
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec974479650.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fcntl  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec974479650.dir/CheckFunctionExists.c.o  -o cmTryCompileExec974479650 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fdopendir exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2542943725/fast"
make -f CMakeFiles/cmTryCompileExec2542943725.dir/build.make CMakeFiles/cmTryCompileExec2542943725.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2542943725.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin   -o CMakeFiles/cmTryCompileExec2542943725.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2542943725
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2542943725.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fdopendir  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2542943725.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2542943725 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstat exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1656702944/fast"
make -f CMakeFiles/cmTryCompileExec1656702944.dir/build.make CMakeFiles/cmTryCompileExec1656702944.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1656702944.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1656702944.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1656702944
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1656702944.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstat  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1656702944.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1656702944 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstatat exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3499787002/fast"
make -f CMakeFiles/cmTryCompileExec3499787002.dir/build.make CMakeFiles/cmTryCompileExec3499787002.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3499787002.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3499787002.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3499787002
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3499787002.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstatat  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3499787002.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3499787002 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstatfs exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3109317348/fast"
make -f CMakeFiles/cmTryCompileExec3109317348.dir/build.make CMakeFiles/cmTryCompileExec3109317348.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3109317348.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3109317348.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3109317348
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3109317348.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstatfs  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3109317348.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3109317348 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fstatvfs exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2671364836/fast"
make -f CMakeFiles/cmTryCompileExec2671364836.dir/build.make CMakeFiles/cmTryCompileExec2671364836.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2671364836.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2671364836.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2671364836
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2671364836.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fstatvfs  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2671364836.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2671364836 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function futimens exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3425396365/fast"
make -f CMakeFiles/cmTryCompileExec3425396365.dir/build.make CMakeFiles/cmTryCompileExec3425396365.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3425396365.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin   -o CMakeFiles/cmTryCompileExec3425396365.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3425396365
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3425396365.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=futimens  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3425396365.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3425396365 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function futimes exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3090965397/fast"
make -f CMakeFiles/cmTryCompileExec3090965397.dir/build.make CMakeFiles/cmTryCompileExec3090965397.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3090965397.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec3090965397.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3090965397
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3090965397.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=futimes  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3090965397.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3090965397 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function futimesat exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3223406184/fast"
make -f CMakeFiles/cmTryCompileExec3223406184.dir/build.make CMakeFiles/cmTryCompileExec3223406184.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3223406184.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3223406184.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3223406184
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3223406184.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=futimesat  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3223406184.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3223406184 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getgrgid_r exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3106482816/fast"
make -f CMakeFiles/cmTryCompileExec3106482816.dir/build.make CMakeFiles/cmTryCompileExec3106482816.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3106482816.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3106482816.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3106482816
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3106482816.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3106482816.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3106482816 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getgrnam_r exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1149755700/fast"
make -f CMakeFiles/cmTryCompileExec1149755700.dir/build.make CMakeFiles/cmTryCompileExec1149755700.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1149755700.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec1149755700.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1149755700
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1149755700.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1149755700.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1149755700 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getpwnam_r exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec685979239/fast"
make -f CMakeFiles/cmTryCompileExec685979239.dir/build.make CMakeFiles/cmTryCompileExec685979239.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec685979239.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec685979239.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec685979239
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec685979239.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec685979239.dir/CheckFunctionExists.c.o  -o cmTryCompileExec685979239 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getpwuid_r exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3408409360/fast"
make -f CMakeFiles/cmTryCompileExec3408409360.dir/build.make CMakeFiles/cmTryCompileExec3408409360.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3408409360.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin   -o CMakeFiles/cmTryCompileExec3408409360.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3408409360
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3408409360.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3408409360.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3408409360 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function getpid exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3708941869/fast"
make -f CMakeFiles/cmTryCompileExec3708941869.dir/build.make CMakeFiles/cmTryCompileExec3708941869.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3708941869.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin   -o CMakeFiles/cmTryCompileExec3708941869.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3708941869
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3708941869.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=getpid  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3708941869.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3708941869 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function lchown exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1450154493/fast"
make -f CMakeFiles/cmTryCompileExec1450154493.dir/build.make CMakeFiles/cmTryCompileExec1450154493.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1450154493.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin   -o CMakeFiles/cmTryCompileExec1450154493.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1450154493
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1450154493.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=lchown  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1450154493.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1450154493 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function link exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3435230790/fast"
make -f CMakeFiles/cmTryCompileExec3435230790.dir/build.make CMakeFiles/cmTryCompileExec3435230790.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3435230790.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin   -o CMakeFiles/cmTryCompileExec3435230790.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3435230790
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3435230790.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=link  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3435230790.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3435230790 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function lstat exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1253084429/fast"
make -f CMakeFiles/cmTryCompileExec1253084429.dir/build.make CMakeFiles/cmTryCompileExec1253084429.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1253084429.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin   -o CMakeFiles/cmTryCompileExec1253084429.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1253084429
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1253084429.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=lstat  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1253084429.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1253084429 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function lutimes exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec976850011/fast"
make -f CMakeFiles/cmTryCompileExec976850011.dir/build.make CMakeFiles/cmTryCompileExec976850011.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec976850011.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec976850011.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec976850011
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec976850011.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=lutimes  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec976850011.dir/CheckFunctionExists.c.o  -o cmTryCompileExec976850011 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mbrtowc exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec156297466/fast"
make -f CMakeFiles/cmTryCompileExec156297466.dir/build.make CMakeFiles/cmTryCompileExec156297466.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec156297466.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin   -o CMakeFiles/cmTryCompileExec156297466.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec156297466
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec156297466.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mbrtowc  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec156297466.dir/CheckFunctionExists.c.o  -o cmTryCompileExec156297466 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mbsnrtowcs exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3766455653/fast"
make -f CMakeFiles/cmTryCompileExec3766455653.dir/build.make CMakeFiles/cmTryCompileExec3766455653.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3766455653.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3766455653.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3766455653
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3766455653.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3766455653.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3766455653 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function memmove exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4173852981/fast"
make -f CMakeFiles/cmTryCompileExec4173852981.dir/build.make CMakeFiles/cmTryCompileExec4173852981.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4173852981.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin   -o CMakeFiles/cmTryCompileExec4173852981.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4173852981
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4173852981.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=memmove  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec4173852981.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4173852981 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mkdir exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1012689680/fast"
make -f CMakeFiles/cmTryCompileExec1012689680.dir/build.make CMakeFiles/cmTryCompileExec1012689680.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1012689680.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin   -o CMakeFiles/cmTryCompileExec1012689680.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1012689680
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1012689680.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mkdir  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1012689680.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1012689680 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mkfifo exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2637694969/fast"
make -f CMakeFiles/cmTryCompileExec2637694969.dir/build.make CMakeFiles/cmTryCompileExec2637694969.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2637694969.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin   -o CMakeFiles/cmTryCompileExec2637694969.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2637694969
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2637694969.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mkfifo  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2637694969.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2637694969 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mknod exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1420240075/fast"
make -f CMakeFiles/cmTryCompileExec1420240075.dir/build.make CMakeFiles/cmTryCompileExec1420240075.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1420240075.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin   -o CMakeFiles/cmTryCompileExec1420240075.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1420240075
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1420240075.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mknod  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1420240075.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1420240075 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function mkstemp exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2186852906/fast"
make -f CMakeFiles/cmTryCompileExec2186852906.dir/build.make CMakeFiles/cmTryCompileExec2186852906.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2186852906.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin   -o CMakeFiles/cmTryCompileExec2186852906.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2186852906
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2186852906.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=mkstemp  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2186852906.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2186852906 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function nl_langinfo exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2454918518/fast"
make -f CMakeFiles/cmTryCompileExec2454918518.dir/build.make CMakeFiles/cmTryCompileExec2454918518.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2454918518.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin   -o CMakeFiles/cmTryCompileExec2454918518.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2454918518
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2454918518.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2454918518.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2454918518 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function openat exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3094800597/fast"
make -f CMakeFiles/cmTryCompileExec3094800597.dir/build.make CMakeFiles/cmTryCompileExec3094800597.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3094800597.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin   -o CMakeFiles/cmTryCompileExec3094800597.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3094800597
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3094800597.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=openat  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3094800597.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3094800597 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function readlink exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1889761756/fast"
make -f CMakeFiles/cmTryCompileExec1889761756.dir/build.make CMakeFiles/cmTryCompileExec1889761756.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1889761756.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec1889761756.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1889761756
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1889761756.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=readlink  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1889761756.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1889761756 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function setenv exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2609651715/fast"
make -f CMakeFiles/cmTryCompileExec2609651715.dir/build.make CMakeFiles/cmTryCompileExec2609651715.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2609651715.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin   -o CMakeFiles/cmTryCompileExec2609651715.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2609651715
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2609651715.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=setenv  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2609651715.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2609651715 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function statfs exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2433403515/fast"
make -f CMakeFiles/cmTryCompileExec2433403515.dir/build.make CMakeFiles/cmTryCompileExec2433403515.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2433403515.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec2433403515.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2433403515
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2433403515.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=statfs  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2433403515.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2433403515 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function statvfs exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3221777966/fast"
make -f CMakeFiles/cmTryCompileExec3221777966.dir/build.make CMakeFiles/cmTryCompileExec3221777966.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3221777966.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin   -o CMakeFiles/cmTryCompileExec3221777966.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3221777966
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3221777966.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=statvfs  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3221777966.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3221777966 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function strchr exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3379666873/fast"
make -f CMakeFiles/cmTryCompileExec3379666873.dir/build.make CMakeFiles/cmTryCompileExec3379666873.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3379666873.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec3379666873.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3379666873
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3379666873.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=strchr  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3379666873.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3379666873 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function strerror exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1361920113/fast"
make -f CMakeFiles/cmTryCompileExec1361920113.dir/build.make CMakeFiles/cmTryCompileExec1361920113.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1361920113.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin   -o CMakeFiles/cmTryCompileExec1361920113.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1361920113
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1361920113.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=strerror  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1361920113.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1361920113 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function strrchr exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2832498066/fast"
make -f CMakeFiles/cmTryCompileExec2832498066.dir/build.make CMakeFiles/cmTryCompileExec2832498066.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2832498066.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin   -o CMakeFiles/cmTryCompileExec2832498066.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2832498066
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2832498066.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=strrchr  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2832498066.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2832498066 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function symlink exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2278669872/fast"
make -f CMakeFiles/cmTryCompileExec2278669872.dir/build.make CMakeFiles/cmTryCompileExec2278669872.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2278669872.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin   -o CMakeFiles/cmTryCompileExec2278669872.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2278669872
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2278669872.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=symlink  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec2278669872.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2278669872 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function timegm exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec667867130/fast"
make -f CMakeFiles/cmTryCompileExec667867130.dir/build.make CMakeFiles/cmTryCompileExec667867130.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec667867130.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin   -o CMakeFiles/cmTryCompileExec667867130.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec667867130
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec667867130.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=timegm  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec667867130.dir/CheckFunctionExists.c.o  -o cmTryCompileExec667867130 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function tzset exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4292854598/fast"
make -f CMakeFiles/cmTryCompileExec4292854598.dir/build.make CMakeFiles/cmTryCompileExec4292854598.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4292854598.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin   -o CMakeFiles/cmTryCompileExec4292854598.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4292854598
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4292854598.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=tzset  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec4292854598.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4292854598 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function utimes exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec62676233/fast"
make -f CMakeFiles/cmTryCompileExec62676233.dir/build.make CMakeFiles/cmTryCompileExec62676233.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec62676233.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin   -o CMakeFiles/cmTryCompileExec62676233.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec62676233
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec62676233.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=utimes  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec62676233.dir/CheckFunctionExists.c.o  -o cmTryCompileExec62676233 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function utimensat exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4067202400/fast"
make -f CMakeFiles/cmTryCompileExec4067202400.dir/build.make CMakeFiles/cmTryCompileExec4067202400.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4067202400.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin   -o CMakeFiles/cmTryCompileExec4067202400.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4067202400
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4067202400.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=utimensat  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec4067202400.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4067202400 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function vfork exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3834636223/fast"
make -f CMakeFiles/cmTryCompileExec3834636223.dir/build.make CMakeFiles/cmTryCompileExec3834636223.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3834636223.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin   -o CMakeFiles/cmTryCompileExec3834636223.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3834636223
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3834636223.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=vfork  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3834636223.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3834636223 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcrtomb exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3822131522/fast"
make -f CMakeFiles/cmTryCompileExec3822131522.dir/build.make CMakeFiles/cmTryCompileExec3822131522.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3822131522.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec3822131522.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3822131522
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3822131522.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcrtomb  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3822131522.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3822131522 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcscmp exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1626783895/fast"
make -f CMakeFiles/cmTryCompileExec1626783895.dir/build.make CMakeFiles/cmTryCompileExec1626783895.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1626783895.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec1626783895.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1626783895
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1626783895.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcscmp  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1626783895.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1626783895 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcscpy exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1601359190/fast"
make -f CMakeFiles/cmTryCompileExec1601359190.dir/build.make CMakeFiles/cmTryCompileExec1601359190.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1601359190.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec1601359190.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1601359190
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1601359190.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcscpy  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1601359190.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1601359190 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcslen exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1197397469/fast"
make -f CMakeFiles/cmTryCompileExec1197397469.dir/build.make CMakeFiles/cmTryCompileExec1197397469.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1197397469.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin   -o CMakeFiles/cmTryCompileExec1197397469.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1197397469
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1197397469.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcslen  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1197397469.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1197397469 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wcsnrtombs exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1866495631/fast"
make -f CMakeFiles/cmTryCompileExec1866495631.dir/build.make CMakeFiles/cmTryCompileExec1866495631.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1866495631.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin   -o CMakeFiles/cmTryCompileExec1866495631.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1866495631
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1866495631.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1866495631.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1866495631 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wctomb exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1921216510/fast"
make -f CMakeFiles/cmTryCompileExec1921216510.dir/build.make CMakeFiles/cmTryCompileExec1921216510.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1921216510.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin   -o CMakeFiles/cmTryCompileExec1921216510.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1921216510
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1921216510.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wctomb  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec1921216510.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1921216510 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function fseeko exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec983532477/fast"
make -f CMakeFiles/cmTryCompileExec983532477.dir/build.make CMakeFiles/cmTryCompileExec983532477.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec983532477.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin   -o CMakeFiles/cmTryCompileExec983532477.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec983532477
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec983532477.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=fseeko  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec983532477.dir/CheckFunctionExists.c.o  -o cmTryCompileExec983532477 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function vprintf exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3383552872/fast"
make -f CMakeFiles/cmTryCompileExec3383552872.dir/build.make CMakeFiles/cmTryCompileExec3383552872.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3383552872.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin   -o CMakeFiles/cmTryCompileExec3383552872.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3383552872
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3383552872.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=vprintf  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec3383552872.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3383552872 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcmp exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4256164356/fast"
make -f CMakeFiles/cmTryCompileExec4256164356.dir/build.make CMakeFiles/cmTryCompileExec4256164356.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4256164356.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin   -o CMakeFiles/cmTryCompileExec4256164356.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4256164356
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4256164356.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wmemcmp  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec4256164356.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4256164356 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wmemcpy exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec51366105/fast"
make -f CMakeFiles/cmTryCompileExec51366105.dir/build.make CMakeFiles/cmTryCompileExec51366105.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec51366105.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin   -o CMakeFiles/cmTryCompileExec51366105.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec51366105
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec51366105.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DCHECK_FUNCTION_EXISTS=wmemcpy  -fno-builtin   -static-libgcc CMakeFiles/cmTryCompileExec51366105.dir/CheckFunctionExists.c.o  -o cmTryCompileExec51366105 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_READDIR_R succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2689423741/fast"
make -f CMakeFiles/cmTryCompileExec2689423741.dir/build.make CMakeFiles/cmTryCompileExec2689423741.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2689423741.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_READDIR_R   -o CMakeFiles/cmTryCompileExec2689423741.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2689423741
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2689423741.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_READDIR_R   -static-libgcc CMakeFiles/cmTryCompileExec2689423741.dir/src.c.o  -o cmTryCompileExec2689423741 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <dirent.h>
int main() {DIR *d = opendir("."); struct dirent e,*r; return readdir_r(d,&e,&r);}
Performing C SOURCE FILE Test HAVE_READLINKAT succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2488143501/fast"
make -f CMakeFiles/cmTryCompileExec2488143501.dir/build.make CMakeFiles/cmTryCompileExec2488143501.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2488143501.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_READLINKAT   -o CMakeFiles/cmTryCompileExec2488143501.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2488143501
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2488143501.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_READLINKAT   -static-libgcc CMakeFiles/cmTryCompileExec2488143501.dir/src.c.o  -o cmTryCompileExec2488143501 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <fcntl.h>
#include <unistd.h>
int main() {char buf[10]; return readlinkat(AT_FDCWD, "", buf, 0);}
Performing C SOURCE FILE Test MAJOR_IN_SYSMACROS succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec85776500/fast"
make -f CMakeFiles/cmTryCompileExec85776500.dir/build.make CMakeFiles/cmTryCompileExec85776500.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec85776500.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DMAJOR_IN_SYSMACROS   -o CMakeFiles/cmTryCompileExec85776500.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec85776500
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec85776500.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DMAJOR_IN_SYSMACROS   -static-libgcc CMakeFiles/cmTryCompileExec85776500.dir/src.c.o  -o cmTryCompileExec85776500 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
#include <sys/sysmacros.h>
int main() { return major(256); }
Determining if the EILSEQ exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2961276741/fast"
make -f CMakeFiles/cmTryCompileExec2961276741.dir/build.make CMakeFiles/cmTryCompileExec2961276741.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2961276741.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2961276741.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2961276741
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2961276741.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2961276741.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2961276741 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <errno.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef EILSEQ
  return ((int*)(&EILSEQ))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MAX exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3642032512/fast"
make -f CMakeFiles/cmTryCompileExec3642032512.dir/build.make CMakeFiles/cmTryCompileExec3642032512.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3642032512.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3642032512.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3642032512
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3642032512.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3642032512.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3642032512 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MAX
  return ((int*)(&INT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MIN exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3969743544/fast"
make -f CMakeFiles/cmTryCompileExec3969743544.dir/build.make CMakeFiles/cmTryCompileExec3969743544.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3969743544.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3969743544.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3969743544
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3969743544.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3969743544.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3969743544 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MIN
  return ((int*)(&INT64_MIN))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT32_MAX exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2051570401/fast"
make -f CMakeFiles/cmTryCompileExec2051570401.dir/build.make CMakeFiles/cmTryCompileExec2051570401.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2051570401.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2051570401.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2051570401
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2051570401.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2051570401.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2051570401 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT32_MAX
  return ((int*)(&UINT32_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT64_MAX exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3637299614/fast"
make -f CMakeFiles/cmTryCompileExec3637299614.dir/build.make CMakeFiles/cmTryCompileExec3637299614.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3637299614.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3637299614.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3637299614
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3637299614.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3637299614.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3637299614 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT64_MAX
  return ((int*)(&UINT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIZE_MAX exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec578911375/fast"
make -f CMakeFiles/cmTryCompileExec578911375.dir/build.make CMakeFiles/cmTryCompileExec578911375.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec578911375.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec578911375.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec578911375
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec578911375.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec578911375.dir/CheckSymbolExists.c.o  -o cmTryCompileExec578911375 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIZE_MAX
  return ((int*)(&SIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SSIZE_MAX exist passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec892518722/fast"
make -f CMakeFiles/cmTryCompileExec892518722.dir/build.make CMakeFiles/cmTryCompileExec892518722.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec892518722.dir/CheckSymbolExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec892518722.dir/CheckSymbolExists.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec892518722
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec892518722.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec892518722.dir/CheckSymbolExists.c.o  -o cmTryCompileExec892518722 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

File /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SSIZE_MAX
  return ((int*)(&SSIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing C SOURCE FILE Test HAVE_STRUCT_TM_TM_GMTOFF succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec410522877/fast"
make -f CMakeFiles/cmTryCompileExec410522877.dir/build.make CMakeFiles/cmTryCompileExec410522877.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec410522877.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_STRUCT_TM_TM_GMTOFF   -o CMakeFiles/cmTryCompileExec410522877.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec410522877
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec410522877.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_STRUCT_TM_TM_GMTOFF   -static-libgcc CMakeFiles/cmTryCompileExec410522877.dir/src.c.o  -o cmTryCompileExec410522877 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <time.h>

int main()
{
   static struct tm tmp;
   if (sizeof(tmp.tm_gmtoff))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3631752888/fast"
make -f CMakeFiles/cmTryCompileExec3631752888.dir/build.make CMakeFiles/cmTryCompileExec3631752888.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3631752888.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -o CMakeFiles/cmTryCompileExec3631752888.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3631752888
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3631752888.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -static-libgcc CMakeFiles/cmTryCompileExec3631752888.dir/src.c.o  -o cmTryCompileExec3631752888 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_mtim.tv_nsec))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_BLKSIZE succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3916178466/fast"
make -f CMakeFiles/cmTryCompileExec3916178466.dir/build.make CMakeFiles/cmTryCompileExec3916178466.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3916178466.dir/src.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE   -o CMakeFiles/cmTryCompileExec3916178466.dir/src.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3916178466
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3916178466.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE   -static-libgcc CMakeFiles/cmTryCompileExec3916178466.dir/src.c.o  -o cmTryCompileExec3916178466 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_blksize))
      return 0;
  return 0;
}

Determining size of short passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec224956119/fast"
make -f CMakeFiles/cmTryCompileExec224956119.dir/build.make CMakeFiles/cmTryCompileExec224956119.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec224956119.dir/SIZE_OF_SHORT.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec224956119.dir/SIZE_OF_SHORT.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_SHORT.c
Linking C executable cmTryCompileExec224956119
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec224956119.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec224956119.dir/SIZE_OF_SHORT.c.o  -o cmTryCompileExec224956119 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1169429828/fast"
make -f CMakeFiles/cmTryCompileExec1169429828.dir/build.make CMakeFiles/cmTryCompileExec1169429828.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1169429828.dir/SIZE_OF_INT.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1169429828.dir/SIZE_OF_INT.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_INT.c
Linking C executable cmTryCompileExec1169429828
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1169429828.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1169429828.dir/SIZE_OF_INT.c.o  -o cmTryCompileExec1169429828 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec217873044/fast"
make -f CMakeFiles/cmTryCompileExec217873044.dir/build.make CMakeFiles/cmTryCompileExec217873044.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec217873044.dir/SIZE_OF_LONG.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec217873044.dir/SIZE_OF_LONG.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG.c
Linking C executable cmTryCompileExec217873044
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec217873044.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec217873044.dir/SIZE_OF_LONG.c.o  -o cmTryCompileExec217873044 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3678300991/fast"
make -f CMakeFiles/cmTryCompileExec3678300991.dir/build.make CMakeFiles/cmTryCompileExec3678300991.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3678300991.dir/SIZE_OF_LONG_LONG.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3678300991.dir/SIZE_OF_LONG_LONG.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_LONG_LONG.c
Linking C executable cmTryCompileExec3678300991
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3678300991.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3678300991.dir/SIZE_OF_LONG_LONG.c.o  -o cmTryCompileExec3678300991 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned short passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec308652669/fast"
make -f CMakeFiles/cmTryCompileExec308652669.dir/build.make CMakeFiles/cmTryCompileExec308652669.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec308652669.dir/SIZE_OF_UNSIGNED_SHORT.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec308652669.dir/SIZE_OF_UNSIGNED_SHORT.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec308652669
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec308652669.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec308652669.dir/SIZE_OF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec308652669 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1760275571/fast"
make -f CMakeFiles/cmTryCompileExec1760275571.dir/build.make CMakeFiles/cmTryCompileExec1760275571.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1760275571.dir/SIZE_OF_UNSIGNED.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1760275571.dir/SIZE_OF_UNSIGNED.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED.c
Linking C executable cmTryCompileExec1760275571
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1760275571.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1760275571.dir/SIZE_OF_UNSIGNED.c.o  -o cmTryCompileExec1760275571 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1513423589/fast"
make -f CMakeFiles/cmTryCompileExec1513423589.dir/build.make CMakeFiles/cmTryCompileExec1513423589.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1513423589.dir/SIZE_OF_UNSIGNED_LONG.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1513423589.dir/SIZE_OF_UNSIGNED_LONG.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG.c
Linking C executable cmTryCompileExec1513423589
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1513423589.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1513423589.dir/SIZE_OF_UNSIGNED_LONG.c.o  -o cmTryCompileExec1513423589 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of unsigned long long passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec260873508/fast"
make -f CMakeFiles/cmTryCompileExec260873508.dir/build.make CMakeFiles/cmTryCompileExec260873508.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec260873508.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec260873508.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG_LONG.c
Linking C executable cmTryCompileExec260873508
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec260873508.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec260873508.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o  -o cmTryCompileExec260873508 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int16_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4240611006/fast"
make -f CMakeFiles/cmTryCompileExec4240611006.dir/build.make CMakeFiles/cmTryCompileExec4240611006.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4240611006.dir/INT16_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec4240611006.dir/INT16_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INT16_T.c
Linking C executable cmTryCompileExec4240611006
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4240611006.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec4240611006.dir/INT16_T.c.o  -o cmTryCompileExec4240611006 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int32_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2616439378/fast"
make -f CMakeFiles/cmTryCompileExec2616439378.dir/build.make CMakeFiles/cmTryCompileExec2616439378.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2616439378.dir/INT32_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2616439378.dir/INT32_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INT32_T.c
Linking C executable cmTryCompileExec2616439378
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2616439378.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2616439378.dir/INT32_T.c.o  -o cmTryCompileExec2616439378 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of int64_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2423398394/fast"
make -f CMakeFiles/cmTryCompileExec2423398394.dir/build.make CMakeFiles/cmTryCompileExec2423398394.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2423398394.dir/INT64_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2423398394.dir/INT64_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INT64_T.c
Linking C executable cmTryCompileExec2423398394
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2423398394.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2423398394.dir/INT64_T.c.o  -o cmTryCompileExec2423398394 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of intmax_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec578929170/fast"
make -f CMakeFiles/cmTryCompileExec578929170.dir/build.make CMakeFiles/cmTryCompileExec578929170.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec578929170.dir/INTMAX_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec578929170.dir/INTMAX_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INTMAX_T.c
Linking C executable cmTryCompileExec578929170
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec578929170.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec578929170.dir/INTMAX_T.c.o  -o cmTryCompileExec578929170 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint8_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec181733434/fast"
make -f CMakeFiles/cmTryCompileExec181733434.dir/build.make CMakeFiles/cmTryCompileExec181733434.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec181733434.dir/UINT8_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec181733434.dir/UINT8_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT8_T.c
Linking C executable cmTryCompileExec181733434
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec181733434.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec181733434.dir/UINT8_T.c.o  -o cmTryCompileExec181733434 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint16_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec766445802/fast"
make -f CMakeFiles/cmTryCompileExec766445802.dir/build.make CMakeFiles/cmTryCompileExec766445802.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec766445802.dir/UINT16_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec766445802.dir/UINT16_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT16_T.c
Linking C executable cmTryCompileExec766445802
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec766445802.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec766445802.dir/UINT16_T.c.o  -o cmTryCompileExec766445802 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint32_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1782957644/fast"
make -f CMakeFiles/cmTryCompileExec1782957644.dir/build.make CMakeFiles/cmTryCompileExec1782957644.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1782957644.dir/UINT32_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1782957644.dir/UINT32_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT32_T.c
Linking C executable cmTryCompileExec1782957644
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1782957644.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1782957644.dir/UINT32_T.c.o  -o cmTryCompileExec1782957644 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uint64_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1682320378/fast"
make -f CMakeFiles/cmTryCompileExec1682320378.dir/build.make CMakeFiles/cmTryCompileExec1682320378.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1682320378.dir/UINT64_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1682320378.dir/UINT64_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINT64_T.c
Linking C executable cmTryCompileExec1682320378
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1682320378.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1682320378.dir/UINT64_T.c.o  -o cmTryCompileExec1682320378 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uintmax_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3576803657/fast"
make -f CMakeFiles/cmTryCompileExec3576803657.dir/build.make CMakeFiles/cmTryCompileExec3576803657.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3576803657.dir/UINTMAX_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3576803657.dir/UINTMAX_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINTMAX_T.c
Linking C executable cmTryCompileExec3576803657
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3576803657.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3576803657.dir/UINTMAX_T.c.o  -o cmTryCompileExec3576803657 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of dev_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1048024101/fast"
make -f CMakeFiles/cmTryCompileExec1048024101.dir/build.make CMakeFiles/cmTryCompileExec1048024101.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1048024101.dir/DEV_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1048024101.dir/DEV_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/DEV_T.c
Linking C executable cmTryCompileExec1048024101
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1048024101.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1048024101.dir/DEV_T.c.o  -o cmTryCompileExec1048024101 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of gid_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2614090348/fast"
make -f CMakeFiles/cmTryCompileExec2614090348.dir/build.make CMakeFiles/cmTryCompileExec2614090348.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2614090348.dir/GID_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2614090348.dir/GID_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/GID_T.c
Linking C executable cmTryCompileExec2614090348
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2614090348.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2614090348.dir/GID_T.c.o  -o cmTryCompileExec2614090348 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of id_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1640148114/fast"
make -f CMakeFiles/cmTryCompileExec1640148114.dir/build.make CMakeFiles/cmTryCompileExec1640148114.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1640148114.dir/ID_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1640148114.dir/ID_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/ID_T.c
Linking C executable cmTryCompileExec1640148114
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1640148114.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1640148114.dir/ID_T.c.o  -o cmTryCompileExec1640148114 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of mode_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3452390190/fast"
make -f CMakeFiles/cmTryCompileExec3452390190.dir/build.make CMakeFiles/cmTryCompileExec3452390190.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3452390190.dir/MODE_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3452390190.dir/MODE_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/MODE_T.c
Linking C executable cmTryCompileExec3452390190
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3452390190.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3452390190.dir/MODE_T.c.o  -o cmTryCompileExec3452390190 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of off_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2837739874/fast"
make -f CMakeFiles/cmTryCompileExec2837739874.dir/build.make CMakeFiles/cmTryCompileExec2837739874.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2837739874.dir/OFF_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2837739874.dir/OFF_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/OFF_T.c
Linking C executable cmTryCompileExec2837739874
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2837739874.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2837739874.dir/OFF_T.c.o  -o cmTryCompileExec2837739874 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1133544538/fast"
make -f CMakeFiles/cmTryCompileExec1133544538.dir/build.make CMakeFiles/cmTryCompileExec1133544538.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1133544538.dir/SIZE_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec1133544538.dir/SIZE_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZE_T.c
Linking C executable cmTryCompileExec1133544538
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1133544538.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec1133544538.dir/SIZE_T.c.o  -o cmTryCompileExec1133544538 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3470649957/fast"
make -f CMakeFiles/cmTryCompileExec3470649957.dir/build.make CMakeFiles/cmTryCompileExec3470649957.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3470649957.dir/SSIZE_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3470649957.dir/SSIZE_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SSIZE_T.c
Linking C executable cmTryCompileExec3470649957
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3470649957.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3470649957.dir/SSIZE_T.c.o  -o cmTryCompileExec3470649957 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uid_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3351653079/fast"
make -f CMakeFiles/cmTryCompileExec3351653079.dir/build.make CMakeFiles/cmTryCompileExec3351653079.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3351653079.dir/UID_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec3351653079.dir/UID_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UID_T.c
Linking C executable cmTryCompileExec3351653079
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3351653079.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec3351653079.dir/UID_T.c.o  -o cmTryCompileExec3351653079 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of pid_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec965980756/fast"
make -f CMakeFiles/cmTryCompileExec965980756.dir/build.make CMakeFiles/cmTryCompileExec965980756.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec965980756.dir/PID_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec965980756.dir/PID_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/PID_T.c
Linking C executable cmTryCompileExec965980756
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec965980756.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec965980756.dir/PID_T.c.o  -o cmTryCompileExec965980756 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of intptr_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2426526162/fast"
make -f CMakeFiles/cmTryCompileExec2426526162.dir/build.make CMakeFiles/cmTryCompileExec2426526162.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2426526162.dir/INTPTR_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2426526162.dir/INTPTR_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/INTPTR_T.c
Linking C executable cmTryCompileExec2426526162
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2426526162.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2426526162.dir/INTPTR_T.c.o  -o cmTryCompileExec2426526162 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of uintptr_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2413908906/fast"
make -f CMakeFiles/cmTryCompileExec2413908906.dir/build.make CMakeFiles/cmTryCompileExec2413908906.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2413908906.dir/UINTPTR_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec2413908906.dir/UINTPTR_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/UINTPTR_T.c
Linking C executable cmTryCompileExec2413908906
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2413908906.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec2413908906.dir/UINTPTR_T.c.o  -o cmTryCompileExec2413908906 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining size of wchar_t passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4149016244/fast"
make -f CMakeFiles/cmTryCompileExec4149016244.dir/build.make CMakeFiles/cmTryCompileExec4149016244.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4149016244.dir/SIZEOF_WCHAR_T.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -o CMakeFiles/cmTryCompileExec4149016244.dir/SIZEOF_WCHAR_T.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/SIZEOF_WCHAR_T.c
Linking C executable cmTryCompileExec4149016244
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4149016244.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w     -static-libgcc CMakeFiles/cmTryCompileExec4149016244.dir/SIZEOF_WCHAR_T.c.o  -o cmTryCompileExec4149016244 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Checking support for ARCHIVE_CRYPTO_MD5_LIBC failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1349056455/fast"
make -f CMakeFiles/cmTryCompileExec1349056455.dir/build.make CMakeFiles/cmTryCompileExec1349056455.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1349056455.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1349056455.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:61:17: fatal error: md5.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec1349056455.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec1349056455/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBC failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2316520722/fast"
make -f CMakeFiles/cmTryCompileExec2316520722.dir/build.make CMakeFiles/cmTryCompileExec2316520722.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2316520722.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2316520722.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:64:20: fatal error: rmd160.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2316520722.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2316520722/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBC failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1139860293/fast"
make -f CMakeFiles/cmTryCompileExec1139860293.dir/build.make CMakeFiles/cmTryCompileExec1139860293.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1139860293.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1139860293.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:67:18: fatal error: sha1.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec1139860293.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec1139860293/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2530890285/fast"
make -f CMakeFiles/cmTryCompileExec2530890285.dir/build.make CMakeFiles/cmTryCompileExec2530890285.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2530890285.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2530890285.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2530890285.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2530890285/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4229486936/fast"
make -f CMakeFiles/cmTryCompileExec4229486936.dir/build.make CMakeFiles/cmTryCompileExec4229486936.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4229486936.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4229486936.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec4229486936.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec4229486936/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2786180843/fast"
make -f CMakeFiles/cmTryCompileExec2786180843.dir/build.make CMakeFiles/cmTryCompileExec2786180843.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2786180843.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2786180843.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2786180843.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2786180843/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC2 failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4245235687/fast"
make -f CMakeFiles/cmTryCompileExec4245235687.dir/build.make CMakeFiles/cmTryCompileExec4245235687.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4245235687.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4245235687.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec4245235687.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec4245235687/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC2 failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1482845566/fast"
make -f CMakeFiles/cmTryCompileExec1482845566.dir/build.make CMakeFiles/cmTryCompileExec1482845566.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1482845566.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1482845566.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec1482845566.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec1482845566/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC2 failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2410465104/fast"
make -f CMakeFiles/cmTryCompileExec2410465104.dir/build.make CMakeFiles/cmTryCompileExec2410465104.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2410465104.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2410465104.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2410465104.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2410465104/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC3 failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec264139967/fast"
make -f CMakeFiles/cmTryCompileExec264139967.dir/build.make CMakeFiles/cmTryCompileExec264139967.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec264139967.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec264139967.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec264139967.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec264139967/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC3 failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3483048554/fast"
make -f CMakeFiles/cmTryCompileExec3483048554.dir/build.make CMakeFiles/cmTryCompileExec3483048554.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3483048554.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3483048554.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec3483048554.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec3483048554/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC3 failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4111760044/fast"
make -f CMakeFiles/cmTryCompileExec4111760044.dir/build.make CMakeFiles/cmTryCompileExec4111760044.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4111760044.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4111760044.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:18: fatal error: sha2.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec4111760044.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec4111760044/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec573255400/fast"
make -f CMakeFiles/cmTryCompileExec573255400.dir/build.make CMakeFiles/cmTryCompileExec573255400.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec573255400.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec573255400.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec573255400.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec573255400/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec994500546/fast"
make -f CMakeFiles/cmTryCompileExec994500546.dir/build.make CMakeFiles/cmTryCompileExec994500546.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec994500546.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec994500546.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec994500546.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec994500546/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec930022038/fast"
make -f CMakeFiles/cmTryCompileExec930022038.dir/build.make CMakeFiles/cmTryCompileExec930022038.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec930022038.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec930022038.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec930022038.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec930022038/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1917322302/fast"
make -f CMakeFiles/cmTryCompileExec1917322302.dir/build.make CMakeFiles/cmTryCompileExec1917322302.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1917322302.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1917322302.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec1917322302.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec1917322302/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1565922445/fast"
make -f CMakeFiles/cmTryCompileExec1565922445.dir/build.make CMakeFiles/cmTryCompileExec1565922445.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1565922445.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1565922445.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:39: fatal error: CommonCrypto/CommonDigest.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec1565922445.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec1565922445/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBMD failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1057860360/fast"
make -f CMakeFiles/cmTryCompileExec1057860360.dir/build.make CMakeFiles/cmTryCompileExec1057860360.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1057860360.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1057860360.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:91:17: fatal error: md5.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec1057860360.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec1057860360/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBMD failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2783529833/fast"
make -f CMakeFiles/cmTryCompileExec2783529833.dir/build.make CMakeFiles/cmTryCompileExec2783529833.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2783529833.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2783529833.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:94:20: fatal error: ripemd.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2783529833.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2783529833/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBMD failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2280230690/fast"
make -f CMakeFiles/cmTryCompileExec2280230690.dir/build.make CMakeFiles/cmTryCompileExec2280230690.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2280230690.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2280230690.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:97:17: fatal error: sha.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2280230690.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2280230690/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBMD failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1979536358/fast"
make -f CMakeFiles/cmTryCompileExec1979536358.dir/build.make CMakeFiles/cmTryCompileExec1979536358.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1979536358.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1979536358.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:100:20: fatal error: sha256.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec1979536358.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec1979536358/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBMD failed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2908781037/fast"
make -f CMakeFiles/cmTryCompileExec2908781037.dir/build.make CMakeFiles/cmTryCompileExec2908781037.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2908781037.dir/check_crypto_md.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2  -w   -I/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive -I/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2908781037.dir/check_crypto_md.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/check_crypto_md.c:36:0:
/source/cmake-2.8.10.2/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:103:20: fatal error: sha512.h: No such file or directory
compilation terminated.
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
make[1]: *** [CMakeFiles/cmTryCompileExec2908781037.dir/check_crypto_md.c.o] Error 1
make: *** [cmTryCompileExec2908781037/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Determining size of unsigned short passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2441962197/fast"
make -f CMakeFiles/cmTryCompileExec2441962197.dir/build.make CMakeFiles/cmTryCompileExec2441962197.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2441962197.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec2441962197.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CheckTypeSize/CMAKE_SIZEOF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec2441962197
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2441962197.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec2441962197.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec2441962197 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the function wsyncup exists in the /usr/lib/libncurses.a passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec192439144/fast"
make -f CMakeFiles/cmTryCompileExec192439144.dir/build.make CMakeFiles/cmTryCompileExec192439144.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec192439144.dir/CheckFunctionExists.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DCHECK_FUNCTION_EXISTS=wsyncup   -o CMakeFiles/cmTryCompileExec192439144.dir/CheckFunctionExists.c.o   -c /source/cmake-2.8.10.2/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec192439144
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec192439144.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2   -DCHECK_FUNCTION_EXISTS=wsyncup   -static-libgcc CMakeFiles/cmTryCompileExec192439144.dir/CheckFunctionExists.c.o  -o cmTryCompileExec192439144 -rdynamic -Wl,-Bstatic -lncurses -Wl,-Bdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Determining if the include file elf.h exists passed with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1460481063/fast"
make -f CMakeFiles/cmTryCompileExec1460481063.dir/build.make CMakeFiles/cmTryCompileExec1460481063.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1460481063.dir/CheckIncludeFile.c.o
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -o CMakeFiles/cmTryCompileExec1460481063.dir/CheckIncludeFile.c.o   -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec1460481063
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1460481063.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-gcc   -O2      -static-libgcc CMakeFiles/cmTryCompileExec1460481063.dir/CheckIncludeFile.c.o  -o cmTryCompileExec1460481063 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'


Performing C++ SOURCE FILE Test run_pic_test succeded with the following output:
Change Dir: /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2140309574/fast"
make -f CMakeFiles/cmTryCompileExec2140309574.dir/build.make CMakeFiles/cmTryCompileExec2140309574.dir/build
make[1]: Entering directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_progress_report /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2140309574.dir/src.cxx.o
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2   -Drun_pic_test   -fPIE -o CMakeFiles/cmTryCompileExec2140309574.dir/src.cxx.o -c /source/cmake-2.8.10.2/CMakeFiles/CMakeTmp/src.cxx
Linking CXX executable cmTryCompileExec2140309574
/source/cmake-2.8.10.2/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2140309574.dir/link.txt --verbose=1
/toolchain/bin/i486-TSOL-linux-gnu-g++    -O2   -Drun_pic_test   -static-libgcc CMakeFiles/cmTryCompileExec2140309574.dir/src.cxx.o  -o cmTryCompileExec2140309574 -rdynamic 
make[1]: Leaving directory `/source/cmake-2.8.10.2/CMakeFiles/CMakeTmp'

Source file was:
int main() { return 0;}
