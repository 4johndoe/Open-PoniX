./dock.c:   DockNode *nodes;
./dock.c:      while(dock->nodes) {
./dock.c:         np = dock->nodes->next;
./dock.c:         JXReparentWindow(display, dock->nodes->window, rootWindow, 0, 0);
./dock.c:         Release(dock->nodes);
./dock.c:         dock->nodes = np;
./dock.c:      dock->nodes = NULL;
./dock.c:   for(np = dock->nodes; np; np = np->next) {
./dock.c:   for(np = dock->nodes; np; np = np->next) {
./dock.c:   for(np = dock->nodes; np; np = np->next) {
./dock.c:   for(np = dock->nodes; np; np = np->next) {
./dock.c:   np->next = dock->nodes;
./dock.c:   dock->nodes = np;
./dock.c:   for(np = dock->nodes; np; np = np->next) {
./dock.c:            dock->nodes = np->next;
./dock.c:   for(np = dock->nodes; np; np = np->next) {
./icon.h:   struct ScaledIconNode *nodes;  /**< Scaled versions of the icon. */
./icon.c:   for(np = icon->nodes; np; np = np->next) {
./icon.c:   np->next = icon->nodes;
./icon.c:   icon->nodes = np;
./icon.c:   icon->nodes = NULL;
./icon.c:      while(icon->nodes) {
./icon.c:         np = icon->nodes->next;
./icon.c:         if(icon->nodes->imagePicture != None) {
./icon.c:            JXRenderFreePicture(display, icon->nodes->imagePicture);
./icon.c:         if(icon->nodes->image != None) {
./icon.c:            JXFreePixmap(display, icon->nodes->image);
./icon.c:         if(icon->nodes->mask != None) {
./icon.c:            JXFreePixmap(display, icon->nodes->mask);
./icon.c:         Release(icon->nodes);
./icon.c:         icon->nodes = np;
./clientlist.c:ClientNode *nodes[LAYER_COUNT];
./clientlist.c:      for(np = nodes[layer]; np; np = np->next) {
./clientlist.c:      for(np = nodes[layer]; np; np = np->next) {
./clientlist.c:      for(tp = nodes[x]; tp; tp = tp->next) {
./render.c:   result->next = icon->nodes;
./render.c:   icon->nodes = result;
./desktop.c:      for(np = nodes[x]; np; np = np->next) {
./desktop.c:      for(np = nodes[x]; np; np = np->next) {
./desktop.c:      for(np = nodes[layer]; np; np = np->next) {
./key.c:      for(np = nodes[layer]; np; np = np->next) {
./clientlist.h:extern struct ClientNode *nodes[LAYER_COUNT];
./pager.c:      for(np = nodes[layer]; np; np = np->next) {
./client.c:      nodes[x] = NULL;
./client.c:   np->next = nodes[np->state.layer];
./client.c:   nodes[np->state.layer] = np;
./client.c:      for(tp = nodes[x]; tp; tp = tp->next) {
./client.c:      for(tp = nodes[x]; tp; tp = tp->next) {
./client.c:         tp = nodes[x];
./client.c:                  nodes[tp->state.layer] = next;
./client.c:               tp->next = nodes[layer];
./client.c:               if(nodes[layer]) {
./client.c:                  nodes[layer]->prev = tp;
./client.c:               nodes[layer] = tp;
./client.c:         for(tp = nodes[x]; tp; tp = tp->next) {
./client.c:         for(tp = nodes[x]; tp; tp = tp->next) {
./client.c:         for(tp = nodes[x]; tp; tp = tp->next) {
./client.c:   if(nodes[np->state.layer] != np) {
./client.c:      np->next = nodes[np->state.layer];
./client.c:      nodes[np->state.layer]->prev = np;
./client.c:      nodes[np->state.layer] = np;
./client.c:         for(tp = nodes[x]; tp; tp = tp->next) {
./client.c:               tp->next = nodes[tp->state.layer];
./client.c:               nodes[tp->state.layer]->prev = tp;
./client.c:               nodes[tp->state.layer] = tp;
./client.c:         nodes[np->state.layer] = np->next;
./client.c:      for(np = nodes[layer]; np; np = np->next) {
./client.c:      nodes[np->state.layer] = np->next;
./border.c:      for(np = nodes[layer]; np; np = np->next) {
./taskbar.c:            && np->client == nodes[np->client->state.layer]) {
./taskbar.c:      for(client = nodes[layer]; client; client = client->next) {
./taskbar.c:      for(client = nodes[layer]; client; client = client->next) {
