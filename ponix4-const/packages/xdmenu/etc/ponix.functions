# Functions

#
#
load_lang()
{
	local pre
	local f
	local LNGPATH
	local fullf

	LNGPATH="/share/lang"

	pre=`make_lower "$PONIX_LANG"`

	# when xorg dead, use english
	if [ "$pre" = "en" ] || [ -z "`pidof Xorg`" ] || [ "$XD_USE_CONSOLE" = "ON" ]; then
		pre=
	fi
	

	for f in $1 $2 $3 $4
	do
		if [ -z "$f" ] ; then break ; fi

		fullf="${LNGPATH}/${f}.lang"

		if [ -e "$fullf" ] ;
		then
			. $fullf
		fi

		if [ -z "$pre" ] ; then continue ; fi

		fullf=${fullf}".$pre"

		if [ -e "$fullf" ] ;
		then
			. $fullf
		fi		
	done 		
}


get_hwid()
{
	lspci -n | md5sum | awk '{print $1}'
}

get_debug_level()
{
    local dlevel=1 x=7 num
    num=$1
    while [ $x -gt 0 ] ; do
          let x=x-1
          let dlevel=$((num/(2**x)))
          if [ $dlevel -gt 0 ] ; then
                let num=$((num-(2**x)))
                case $x in
                0)
                  DEBUG_BOOT=1
                  ;;
                1)
                  DEBUG_NETWORK=2
                  ;;
                2)
                  DEBUG_INIT=4
                  ;;
                3)
                  DEBUG_KERNEL=8
                  ;;
                4)
                  DEBUG_MODULES=16
                  ;;
                5)
                  DEBUG_PACKAGES=32
                  ;;
                6)
                  DEBUG_EMAIL=64
                  ;;
                esac
          fi
    done
}

# If ponix.network/user is a dos file, converts it to unix

cleanup ()
{
	if [ -e $TS_NETWORK ] ; then
		sed -e 's/\//g' $TS_NETWORK > $TS_NETWORK.tmp
		cat $TS_NETWORK.tmp > $TS_NETWORK
		rm $TS_NETWORK.tmp
	fi
	if [ -e $TS_USER ] ; then
		sed -e 's/\//g' $TS_USER > $TS_USER.tmp
		cat $TS_USER.tmp > $TS_USER
		rm $TS_USER.tmp
	fi

}

parse_tpl ()  
{
    if [ -f $1.tpl ]; then 
	cat $1.tpl | sed -f /tmp/script > $1
    fi
}

# Log to file and console
echo_log ()
{
	local debug noline string

	until [ -z "$1" ]; do
		case $1 in
		"-n")
			noline="-n"
		;;
		"-d")
			debug="CONSOLE"
		;;
		"-s")
			debug="SCREEN"
		;;
		*)
			string=$1
		;;
		esac
		shift
	done
	if [ "$debug" = "CONSOLE" ] ; then
		echo -e $noline $string > $CONSOLE
	elif [ "$debug" = "SCREEN" ] ; then
		echo -e $noline $string
	fi
	echo -e $noline $string >> $LOGFILE
}

# Ponix version of echo_log relies on exported XD_USE_CONSOLE
# option. if its "ON" then echo on screen and into log file, otherwise only to log file
plog ()
{
	local noline string

	until [ -z "$1" ]; do
		case $1 in
		"-n")
			noline="-n"
		;;
		*)
			string=$1
		;;
		esac
		shift
	done

	if [ -n "$PLOG_NAME" ] ; then
		string=$PLOG_NAME": "$string
	fi

	if [ "$XD_USE_CONSOLE" = "ON" ] ; then
		echo -e $noline $string
	fi
	echo -e $noline $string >> $LOGFILE
}


## PKG functions

pkg_require ()
{
	if  /bin/pkg require $1 ; then
		return 0
	fi

	/bin/xdmenu_errbox "$LNG_DESKRUN_REQUIRED_PKG_NOT_FOUND ${1}."
	return 1
}

pkg_is_loaded ()
{
    if [ -f /var/packages/${1}.loaded ]; then
	return 0
    else
        return 1
    fi
}

pkg_is_executable ()
{
    if [ -x /bin/$1 ] ; then
	return 0
    else
	return 1
    fi
}

pkg_initialized ()
{
    if [ -f /var/packages/$1 ]; then
	return 0
    else
        return 1
    fi
}

pkg_set_init_flag ()
{
    touch /var/packages/$1
}

## Make variable capitals

make_caps ()
{
	echo $1 | tr "[a-z]" "[A-Z]"
}

## start-sesion startup error notice

# various startup scripts may add their warnings
# and finaly start-session will fetch and show them to user, when
# graphics comes up.

set_notice ()
{
	echo "$1" > /tmp/notice
}

add_notice ()
{
	if [ -e "/tmp/notice" ] ; then
		echo "\n\n" >> /tmp/notice
	fi

	echo "$1" >> /tmp/notice
}

fetch_notice ()
{
	if [ -e "/tmp/notice" ] ; then
		cat /tmp/notice
		rm /tmp/notice
	fi	
}

## Session manipulation

is_session_running ()
{
	PID=`eval echo '$SESSION'$1'_PID'`

	if [ -z "$PID" ] ; then
		return 1
	fi

	if [ "`ps | awk '{print $1}' | grep \"^$PID$\"`" = "$PID" ] ; then
		return 0
	else
		return 1
	fi	
}


# These are to get session specific variables more easily:

# get session variable value, one like 'SESSION_0_TYPE'. To obtain it use `sesvar 0 TYPE`
sesvar ()
{
	local VAR_NAME VAR_VALUE
	VAR_NAME='SESSION_'$1'_'$2
	VAR_VALUE="`eval echo '$'$VAR_NAME`"
	echo $VAR_VALUE
}

# get session TYPEd variable value, one like 'SESSION_0_FREERDP_SERVER'. To obtain it use `sestypevar 0 SERVER`
# if session type is freerdp, then the value of 'SESSION_0_FREERDP_SERVER' will be displayed
sestypevar ()
{
	local VAR_NAME VAR_VALUE TYPE
	VAR_NAME='SESSION_'$1'_TYPE'
	TYPE="`eval echo '$'$VAR_NAME`"
	TYPE=`make_caps $TYPE`
	VAR_NAME='SESSION_'$1'_'$TYPE'_'$2		
	VAR_VALUE="`eval echo '$'$VAR_NAME`"
	echo $VAR_VALUE
}

# quick way to learn that session typed variable is ON, for example: SESSION_0_FREERDP_SOUND=On
# be checked like if sestypevar_is_on 0 SOUND ; then ...
sestypevar_is_on ()
{
	local VAL
	VAL=`sestypevar $1 $2`
	VAL=`make_caps "$VAL"`

	if [ "$VAL" == "ON" ] ; then
		return 0
	else
		return 1
	fi
}


# get session TYPEd variable, but consider untyped session independed defaults (if value of session specific variable is empty)
# and finally return a default value of $3 if all previous is empty
# For example: `sestypevar_def 0 SOUND OFF` will try to return values in that order:
#
# 1. $SESSION_0_FREERDP_SOUND (if session 0 type is freerdp)
# 2. $FREERDP_SOUND (if previous is empty)
# 3. 'OFF' (if previous is also empty)
#
sestypevar_def ()
{
	local VAR_NAME VAR_VALUE TYPE
	VAR_NAME='SESSION_'$1'_TYPE'
	TYPE="`eval echo '$'$VAR_NAME`"
	TYPE=`make_caps $TYPE`
	if [ -z "$TYPE" ] ; then
		return 1
	fi
	VAR_NAME='SESSION_'$1'_'$TYPE'_'$2		
	VAR_VALUE="`eval echo '$'$VAR_NAME`"

	if [ -z "$VAR_VALUE" ] ; then
		VAR_NAME=$TYPE'_'$2
		VAR_VALUE="`eval echo '$'$VAR_NAME`"
	fi
	if [ -z "$VAR_VALUE" ] ; then
		VAR_VALUE=$3
	fi
	echo $VAR_VALUE
}


## Make variable lower

make_lower ()
{
	echo $1 | tr "[A-Z]" "[a-z]"
}

make_capital ()
{
   local word words badlist oneword x=0

   if [ "$1" = "-1" ] ; then
     oneword="TRUE"
     shift
   fi
   if [ $# -gt 1 ]; then
	until [ -z "$1" ]
	do
	     let x=x+1
	     case $1 in
	     VNC|TCP|ZLIB|SSL|CUPSD|JPEG|RDP|PNG|IPPPort|IPPPrinting)
		word=$1
		;;
	     *)
		if [ -z "$oneword" ] || [ $x -eq 1 ] ; then
		  word=`echo $1 | cut -c1 | tr "[a-z]" "[A-Z]"`
		  word=$word`echo $1 | cut -c2- | tr "[A-Z]" "[a-z]"`
		else
		  word=`echo $1 | tr "[A-Z]" "[a-z]"`
		fi
		;;
	     esac
	     shift
	     words="$words $word"
	done
	echo $words
   else
	case $1 in
	VNC|TCP|ZLIB|SSL|CUPSD|JPEG|RDP|PNG|IPPPort|IPPPrinting)
	   word=$1
	   ;;
	*)
	  word=`echo $1 | cut -c1 | tr "[a-z]" "[A-Z]"`
	  word=$word`echo $1 | cut -c2- | tr "[A-Z]" "[a-z]"`
	esac
	echo $word
   fi
}

## Replace on or off with #

replace_variable ()
{
	if [ `make_caps $1` = "ON" ] ; then
		echo " "
	else
		echo "#"
	fi
}

## Replace space

replace_char ()
{
	echo $1 | sed -e "s/$2/$3/g"
}

# Check for invalid characters in options line

replace_invalid ()
{
	echo $1 | sed -e 's/ /\\ /g' | sed -e 's/\-/\\\-/g' |  sed -e 's/\//\\\//g'
}

# Overwrite file with sed command

sed_file ()
{
	cat $1 | sed -e $2 > /tmp/sed.tmp
	cat /tmp/sed.tmp > $1
	rm /tmp/sed.tmp
}

## Restart xinetd

restart_xinetd ()
{
	XPID=`pidof xinetd`
	kill -SIGHUP $XPID
}


# Check if Module loaded
check_module ()
{
	if lsmod | grep $1 > /dev/null ; then
		return 0
	else
		return 1
	fi
}

get_filesystems()
{
        for filename in $FILESYSTEMS
        do
                if [ -e $MOD_PATH/inbuilt/$filename.ko ] || [ -e $MOD_PATH/loaded/$filename.ko ] ; then
			if [ "$filename" != "supermount" ] ; then
                		filesystem=$filename:$filesystem
			fi
		        if ! check_module $filename ; then
               			modprobe $filename
        		fi
                fi
        done
	let length=${#filesystem}-1
	if [ "$length" -gt 0 ] ; then
		filesystem=`echo $filesystem | cut -c 1-$length`
	fi
}

